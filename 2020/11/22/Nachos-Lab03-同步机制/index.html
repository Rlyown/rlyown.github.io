<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Nachos Lab03 同步机制 - Real Own</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Chaos Chen"><meta name="msapplication-TileImage" content="/img/f7.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Chaos Chen"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="本实习希望通过对同步互斥相关概念的理解，在Nachos中实现锁、条件变量、barrier等等同步机制，并利用这些机制实现同步互斥实例。"><meta property="og:type" content="blog"><meta property="og:title" content="Nachos Lab03 同步机制"><meta property="og:url" content="https://rlyown.github.io/2020/11/22/Nachos-Lab03-%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/"><meta property="og:site_name" content="Real Own"><meta property="og:description" content="本实习希望通过对同步互斥相关概念的理解，在Nachos中实现锁、条件变量、barrier等等同步机制，并利用这些机制实现同步互斥实例。"><meta property="og:image" content="https://rlyown.github.io/2020/11/22/Nachos-Lab03-%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/KFifo_buffer_1.png"><meta property="og:image" content="https://rlyown.github.io/2020/11/22/Nachos-Lab03-%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/KFifo_buffer_2.png"><meta property="article:published_time" content="2020-11-22T15:22:11.000Z"><meta property="article:modified_time" content="2023-06-30T08:53:26.400Z"><meta property="article:author" content="Chaos Chen"><meta property="article:tag" content="Nachos"><meta property="article:tag" content="Synchronization"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://rlyown.github.io/2020/11/22/Nachos-Lab03-%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/KFifo_buffer_1.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://rlyown.github.io/2020/11/22/Nachos-Lab03-%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/"},"headline":"Nachos Lab03 同步机制","image":["https://rlyown.github.io/2020/11/22/Nachos-Lab03-%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/KFifo_buffer_1.png","https://rlyown.github.io/2020/11/22/Nachos-Lab03-%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/KFifo_buffer_2.png"],"datePublished":"2020-11-22T15:22:11.000Z","dateModified":"2023-06-30T08:53:26.400Z","author":{"@type":"Person","name":"Chaos Chen"},"publisher":{"@type":"Organization","name":"Real Own","logo":{"@type":"ImageObject","url":"https://rlyown.github.io/img/f7.png"}},"description":"本实习希望通过对同步互斥相关概念的理解，在Nachos中实现锁、条件变量、barrier等等同步机制，并利用这些机制实现同步互斥实例。"}</script><link rel="canonical" href="https://rlyown.github.io/2020/11/22/Nachos-Lab03-%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/"><link rel="alternate" href="/atom.xml" title="Real Own" type="application/atom+xml"><link rel="icon" href="/img/f7.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Oxanium:wght@300;400;600&amp;family=Roboto+Mono"><link rel="stylesheet" href="/css/cyberpunk.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/f7.png" alt="Real Own" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/Rlyown/rlyown.github.io"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catálogo" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Buscar" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Publicado hace&nbsp;<time dateTime="2020-11-22T15:22:11.000Z" title="11/22/2020, 11:22:11 PM">2020-11-22</time></span><span class="level-item">Actualizado hace&nbsp;<time dateTime="2023-06-30T08:53:26.400Z" title="6/30/2023, 4:53:26 PM">2023-06-30</time></span><span class="level-item"><a class="link-muted" href="/categories/Operating-System/">Operating System</a></span><span class="level-item">an hour de lectura (Aproximadamente 8862 palabras)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>&nbsp;visitas</span></div></div><h1 class="title is-3 is-size-4-mobile">Nachos Lab03 同步机制</h1><div class="content"><h2 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h2><h3 id="Exercise1-调研"><a href="#Exercise1-调研" class="headerlink" title="Exercise1 调研"></a>Exercise1 调研</h3><blockquote>
<p>调研Linux中实现的同步机制。具体内容见课堂要求。</p>
</blockquote>
<p>Linux中的同步机制有：</p>
<ul>
<li><strong>中断屏蔽</strong>。由于内核的进程调度等操作依赖中断实现，因此可以避免抢占进程间的并发。仅适用于单CPU，不能解决多CPU引发的竞争。</li>
<li><strong>原子操作</strong>。原子操作在内核中主要保护某个共享变量，防止该变量被同时访问造成数据不同步问题。其定义的数据操作中间不会被中断。</li>
<li><strong>信号量</strong>。阻塞式等待的同步互斥机制，保证进程能够正确合理的使用公共资源。</li>
<li><strong>自旋锁</strong>。使用忙等的方法，进程不会阻塞。适用于保持时间较短、可抢占的内核线程、多处理器间共享数据的应用场合。</li>
<li><strong>读写锁、读写自旋锁、读写信号量</strong>。分别针对读、写操作做的处理。写操作时仅允许一个进程进入临界区，读操作允许多个进程进入临界区。适用于读远比写操作频繁的场合。</li>
<li><strong>RCU机制</strong>。随意读，但是在更新数据的时候，先复制一份副本，在副本上完成修改再一次性地更新旧数据。同样是针对读多写少的场合。</li>
<li><strong>内存和优化屏障</strong>。让程序在处理完屏障之前的代码之前，不会处理屏障之后的代码。</li>
<li><strong>顺序锁</strong>。更偏向写者的读写锁。</li>
<li><strong>大内核锁</strong>。与普通的锁类似，但是其存在自动释放的特性，进程会因为主动放弃CPU时自动释放锁，换入CPU时重新获得锁。</li>
</ul>
<h3 id="Exercise2-源代码阅读"><a href="#Exercise2-源代码阅读" class="headerlink" title="Exercise2 源代码阅读"></a>Exercise2 源代码阅读</h3><blockquote>
<p>阅读下列源代码，理解Nachos现有的同步机制。</p>
<ul>
<li><p>code&#x2F;threads&#x2F;synch.h和code&#x2F;threads&#x2F;synch.cc</p>
</li>
<li><p>code&#x2F;threads&#x2F;synchlist.h和code&#x2F;threads&#x2F;synchlist.cc</p>
</li>
</ul>
</blockquote>
<p><em>code&#x2F;threads&#x2F;synch.h**和code&#x2F;threads&#x2F;synch.cc</em>：Nachos提供了三种同步机制信号量、锁和条件变量机制。</p>
<ul>
<li><p>信号量：仅包含P，V两种操作，以及非负的信号量值和等待队列。当信号量值大于0时，P操作将信号量值减少；当信号量值等于0时，P操作将当前线程放入等待队列并睡眠。而V操作则从等待队列取出线程放入就绪队列，然后增加信号量值。</p>
<p>（P操作中的while不能换成if，因为当线程1被唤醒时仍要判断一次value的值，否则可能存在线程刚被唤醒就被换出了CPU。然后新的线程2执行P操作获得了资源，但还未执行V操作时，线程1重新换入CPU，此时value的值是0，但是由于此时没有再次判断value的值，就会导致线程1也会进入临界区。）</p>
</li>
<li><p>锁：一个锁有两种状态BUSY和FREE。当锁处于FREE，线程可以取得锁进入临界区，执行完后，仅能由该线程释放锁。当锁处理BUSY时，申请锁的线程会进入阻塞状态，直到锁被释放变为FREE才被唤醒。</p>
</li>
<li><p>条件变量机制：该机制不包含任何值，或者说可以将其看作一个二值的机制。它需要与锁一同使用。所有的操作仅当线程获得了锁并且是同一个锁的时候，能够执行线程等待条件变量（<em>Wait</em>），唤醒一个等待该条件变量的线程（<em>Signal</em>），唤醒所有等待该条件变量的线程（<em>BroadCast</em>）</p>
</li>
</ul>
<p><em>code&#x2F;threads&#x2F;synchlist.h和code&#x2F;threads&#x2F;synchlist.cc</em>：这里实现了用于同步访问的列表，该列表利用了锁和条件变量两个机制。该列表用于1.当线程需要从中删除元素时，如果没有元素则会让线程等待，直到列表有一个元素；2. 同一时刻仅有一个线程可以访问该列表。</p>
<h4 id="关于线程阻塞后中断的问题"><a href="#关于线程阻塞后中断的问题" class="headerlink" title="关于线程阻塞后中断的问题"></a>关于线程阻塞后中断的问题</h4><p>首先观察线程Thread类下的<em>Yield</em>函数。<em>Yield</em>函数会先关中断；然后在<em>Yield</em>函数的末尾，会直接执行调度器的<em>Run</em>方法去执行下一个线程，此时下一个线程是处于关中断状态的。但是，当执行<em>Yield</em>的线程被重新换入CPU的时候，会从<em>Run</em>后面继续执行，也就会进行开中断。也就是说，<strong>上一个线程在Yield中关中断，切换到下一个线程，然后在下一个线程的Yield中去开中断。</strong></p>
<figure class="highlight c++"><figcaption><span>Yield函数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IntStatus oldLevel = interrupt-&gt;<span class="built_in">SetLevel</span>(IntOff);</span><br><span class="line">...</span><br><span class="line">scheduler-&gt;<span class="built_in">ReadyToRun</span>(<span class="keyword">this</span>);</span><br><span class="line">scheduler-&gt;<span class="built_in">Run</span>(nextThread);</span><br><span class="line">(<span class="type">void</span>) interrupt-&gt;<span class="built_in">SetLevel</span>(oldLevel);</span><br></pre></td></tr></table></figure>

<p>这里会存在一个新的问题。</p>
<blockquote>
<p> 如果新换上的线程是刚刚进过<em>Fork</em>创建的线程，而不是执行<em>Yield</em>换出过的线程，那么新线程又是如何开中断的呢？</p>
</blockquote>
<p>我们进一步观察<em>Fork</em>函数的实现。可以看到在其内部调用了<em>StackAllocate</em>函数来创建线程栈，并且初始化了一些机器状态，其中就有StartupPCState状态指向了开中断函数。这样上述问题就解决了，新线程会在首次执行的时候开中断一次。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">machineState[PCState] = (<span class="type">int</span>*)ThreadRoot;</span><br><span class="line">machineState[StartupPCState] = (<span class="type">int</span>*)InterruptEnable;  <span class="comment">// 开中断</span></span><br><span class="line">machineState[InitialPCState] = (<span class="type">int</span>*)func;</span><br><span class="line">machineState[InitialArgState] = arg;</span><br><span class="line">machineState[WhenDonePCState] = (<span class="type">int</span>*)ThreadFinish;</span><br></pre></td></tr></table></figure>

<p>然后再将视角转向信号量的<em>P操作</em>。在<em>P操作</em>中，线程会先关中断，然后因为请求的资源不足（即<code>value == 0</code>）而将自己睡眠，直到重新被唤醒的时候才开中断。而在Sleep的实现中，并没有去开中断，甚至断言当前的中断状态是关。但是<em>Yield</em>部分和<em>P操作</em>说明了新换入的线程该如何去开中断。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * threads/synch.cc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">Semaphore::P</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IntStatus oldLevel = interrupt-&gt;<span class="built_in">SetLevel</span>(IntOff);  <span class="comment">// disable interrupts</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (value == <span class="number">0</span>) &#123;         <span class="comment">// semaphore not available</span></span><br><span class="line">   queue-&gt;<span class="built_in">Append</span>((<span class="type">void</span> *)currentThread);  <span class="comment">// so go to sleep</span></span><br><span class="line">   currentThread-&gt;<span class="built_in">Sleep</span>();</span><br><span class="line">    &#125; </span><br><span class="line">    value--;               <span class="comment">// semaphore available, </span></span><br><span class="line">                  <span class="comment">// consume its value</span></span><br><span class="line">    </span><br><span class="line">    (<span class="type">void</span>) interrupt-&gt;<span class="built_in">SetLevel</span>(oldLevel);  <span class="comment">// re-enable interrupts</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * threads/thread.cc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">Thread::Sleep</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Thread *nextThread;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">ASSERT</span>(<span class="keyword">this</span> == currentThread);</span><br><span class="line">    <span class="built_in">ASSERT</span>(interrupt-&gt;<span class="built_in">getLevel</span>() == IntOff);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">DEBUG</span>(<span class="string">&#x27;t&#x27;</span>, <span class="string">&quot;Sleeping thread \&quot;%s\&quot;\n&quot;</span>, <span class="built_in">getName</span>());</span><br><span class="line"></span><br><span class="line">    status = BLOCKED;</span><br><span class="line">    <span class="keyword">while</span> ((nextThread = scheduler-&gt;<span class="built_in">FindNextToRun</span>()) == <span class="literal">NULL</span>)</span><br><span class="line">	interrupt-&gt;<span class="built_in">Idle</span>();	<span class="comment">// no one to run, wait for an interrupt</span></span><br><span class="line">        </span><br><span class="line">    scheduler-&gt;<span class="built_in">Run</span>(nextThread); <span class="comment">// returns when we&#x27;ve been signalled</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将上面描述的信息总结起来可以得出结论。<strong>由Sleep陷入阻塞</strong>的线程或者<strong>由Yield切换线程前</strong>所关闭的中断，其开启的时机：</p>
<ol>
<li>被换入的是<strong>新</strong>线程 - 通过StartupPCState中存储的函数指针来开中断</li>
<li>被换入的是<strong>曾经由Yield换出的</strong>线程 - 执行<em>Yield</em>末尾的开中断</li>
<li>被换入的是<strong>从阻塞中被唤醒的</strong>线程 - 继续执行其末尾的开中断（如<em>P操作</em>的末尾的开中断）</li>
</ol>
<h3 id="Exercise3-实现锁和条件变量"><a href="#Exercise3-实现锁和条件变量" class="headerlink" title="Exercise3 实现锁和条件变量"></a>Exercise3 实现锁和条件变量</h3><blockquote>
<p>可以使用sleep和wakeup两个原语操作（注意屏蔽系统中断），也可以使用Semaphore作为唯一同步原语（不必自己编写开关中断的代码）。</p>
</blockquote>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p><strong>锁</strong>：可以借助信号量来实现锁所需的机制。在锁内放置一个信号量<code>lock</code>，尝试获取锁就间接变成了<code>P(lock)</code>操作；而释放锁也就等同于<code>V(lock)</code>操作。此外为了保证锁的特性“仅有持有锁的进程能够释放锁”，增设一个属性用于记录是哪个线程获取到了锁。</p>
<p><strong>条件变量</strong>：条件变量很重要的一点就是内部需要有等待队列以提供阻塞和唤醒功能，因此条件变量内部仅需要维护这样一个等待队列。</p>
<p>当然上述二者的操作均需保证其执行的原子性（对于Nachos保证原子性的方式较为单一，即通过关中断来保证）。</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>首先是关于锁的实现。锁的实现机制是利用信号量机制，在锁中新增两个私有成员owner和lock。owner变量用于记录持有锁的线程，lock变量用于上锁和释放锁的实现。上锁和释放锁的操作均利用关中断来保证操作的原子性。对于上锁Acquire操作，线程先对锁进行P操作，如果锁已经被占用，则该线程会阻塞；反之，则获得锁并设置锁的owner。对于释放锁Release操作，则会先断言释放该锁的线程必须是持有锁的线程，然后V操作释放锁资源并将持有者owner置空。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Lock::<span class="built_in">Lock</span>(<span class="type">char</span>* debugName) &#123;</span><br><span class="line">    name = debugName;</span><br><span class="line">    lock = <span class="keyword">new</span> <span class="built_in">Semaphore</span>(<span class="string">&quot;Called in Lock&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    owner = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Lock::~<span class="built_in">Lock</span>() &#123;</span><br><span class="line">    <span class="keyword">delete</span> lock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Lock::Acquire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IntStatus oldLevel = interrupt-&gt;<span class="built_in">SetLevel</span>(IntOff);</span><br><span class="line">    lock-&gt;<span class="built_in">P</span>();</span><br><span class="line">    owner = currentThread;</span><br><span class="line">    (<span class="type">void</span>) interrupt-&gt;<span class="built_in">SetLevel</span>(oldLevel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Lock::Release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IntStatus oldLevel = interrupt-&gt;<span class="built_in">SetLevel</span>(IntOff);</span><br><span class="line">    <span class="built_in">ASSERT</span>(<span class="built_in">isHeldByCurrentThread</span>());  <span class="comment">// 仅有持有锁的线程才能释放锁</span></span><br><span class="line">    lock-&gt;<span class="built_in">V</span>();</span><br><span class="line">    owner = <span class="literal">NULL</span>;</span><br><span class="line">    (<span class="type">void</span>) interrupt-&gt;<span class="built_in">SetLevel</span>(oldLevel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Lock::isHeldByCurrentThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentThread == owner;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>对于条件变量的实现，则新增了一个等待队列queue，用于记录调用<em>Wait</em>而阻塞的线程。对于等待<em>Wait</em>的实现，则同样先断言获得到锁的线程才能操作条件变量，然后释放锁，阻塞当前线程并将其加入到等待队列；直到线程被唤醒时获取锁，然后进入临界区操作。对于唤醒<em>Signal</em>的实现，则是通过判断等待队列是否为空，如果不为空，则取出一个线程加入到就绪队列。同理<em>Broadcast</em>函数的实现，则是对等待队列的所有线程执行<em>Signal</em>操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Condition::<span class="built_in">Condition</span>(<span class="type">char</span>* debugName) &#123;</span><br><span class="line">    name = debugName;</span><br><span class="line">    queue = <span class="keyword">new</span> List;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Condition::~<span class="built_in">Condition</span>() &#123;</span><br><span class="line">    <span class="keyword">delete</span> queue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Condition::Wait</span><span class="params">(Lock* conditionLock)</span> </span>&#123;</span><br><span class="line"><span class="comment">//    ASSERT(FALSE);</span></span><br><span class="line">    IntStatus oldLevel = interrupt-&gt;<span class="built_in">SetLevel</span>(IntOff);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ASSERT</span>(conditionLock-&gt;<span class="built_in">isHeldByCurrentThread</span>());</span><br><span class="line">    <span class="comment">// 因为无法获得锁的线程会阻塞，因此请求锁的线程仍在执行就说明是有问题的</span></span><br><span class="line">    conditionLock-&gt;<span class="built_in">Release</span>();  <span class="comment">// 睡眠之前释放锁</span></span><br><span class="line">    queue-&gt;<span class="built_in">Append</span>(currentThread);</span><br><span class="line">    currentThread-&gt;<span class="built_in">Sleep</span>();</span><br><span class="line">    conditionLock-&gt;<span class="built_in">Acquire</span>();  <span class="comment">// 被唤醒时重新请求锁，进入临界区</span></span><br><span class="line"></span><br><span class="line">    (<span class="type">void</span>) interrupt-&gt;<span class="built_in">SetLevel</span>(oldLevel);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Condition::Signal</span><span class="params">(Lock* conditionLock)</span> </span>&#123;</span><br><span class="line">    IntStatus oldLevel = interrupt-&gt;<span class="built_in">SetLevel</span>(IntOff);</span><br><span class="line">    <span class="comment">// 取出一个线程加入到就绪队列</span></span><br><span class="line">    <span class="keyword">if</span> (!queue-&gt;<span class="built_in">IsEmpty</span>()) &#123;</span><br><span class="line">        Thread* nextThread = queue-&gt;<span class="built_in">Remove</span>();</span><br><span class="line">        scheduler-&gt;<span class="built_in">ReadyToRun</span>(nextThread);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    (<span class="type">void</span>) interrupt-&gt;<span class="built_in">SetLevel</span>(oldLevel);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Condition::Broadcast</span><span class="params">(Lock* conditionLock)</span> </span>&#123;</span><br><span class="line">    IntStatus oldLevel = interrupt-&gt;<span class="built_in">SetLevel</span>(IntOff);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue-&gt;<span class="built_in">IsEmpty</span>()) &#123;</span><br><span class="line">        <span class="built_in">Signal</span>(conditionLock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    (<span class="type">void</span>) interrupt-&gt;<span class="built_in">SetLevel</span>(oldLevel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Exercise4-实现同步互斥实例"><a href="#Exercise4-实现同步互斥实例" class="headerlink" title="Exercise4 实现同步互斥实例"></a>Exercise4 实现同步互斥实例</h3><blockquote>
<p>基于Nachos中的信号量、锁和条件变量，采用两种方式实现同步和互斥机制应用（其中使用条件变量实现同步互斥机制为必选题目）。具体可选择“生产者-消费者问题”、“读者-写者问题”、“哲学家就餐问题”、“睡眠理发师问题”等。（也可选择其他经典的同步互斥问题）</p>
</blockquote>
<h4 id="生产者-消费者问题（信号量实现）"><a href="#生产者-消费者问题（信号量实现）" class="headerlink" title="生产者-消费者问题（信号量实现）"></a>生产者-消费者问题（信号量实现）</h4><p>设置三个信号量，缓冲区互斥信号量mutex、缓冲区剩余空间信号量empty、缓冲区已有产品信号量full。</p>
<p>然后编写生产者函数<em>Producer</em>，共生产10个产品，每次生产前判断缓冲区是否还有空间，然后再获取互斥变量mutex，接着进入临界区执行生产任务（往缓冲区的空位置写1），最后再释放这些信号量。对于消费者<em>Consumer</em>则与之类似，每次消费前判断缓冲区是否有产品，然后再获取mutex，接着进入临界区执行消费任务（将缓冲区一个为1的位置改为-1），最后同样释放信号量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 信号量</span></span><br><span class="line">Semaphore * mutex = <span class="keyword">new</span> <span class="built_in">Semaphore</span>(<span class="string">&quot;Producer-Consumer-mutex&quot;</span>, <span class="number">1</span>);</span><br><span class="line">Semaphore * full = <span class="keyword">new</span> <span class="built_in">Semaphore</span>(<span class="string">&quot;Producer-Consumer-full&quot;</span>, <span class="number">0</span>);</span><br><span class="line">Semaphore * empty = <span class="keyword">new</span> <span class="built_in">Semaphore</span>(<span class="string">&quot;Producer-Consumer-empty&quot;</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">// 互斥缓冲区</span></span><br><span class="line"><span class="type">int</span> buff[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printBuff</span><span class="params">(<span class="type">char</span> * name)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;===========%s===========\n&quot;</span>, name);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, buff[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n===========End===========\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Producer</span><span class="params">(<span class="type">int</span> which)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (num--) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread %d is trying to produce\n&quot;</span>, which);</span><br><span class="line">        empty-&gt;<span class="built_in">P</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread %d is trying to get mutex\n&quot;</span>, which);</span><br><span class="line">        mutex-&gt;<span class="built_in">P</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread %d is producing\n&quot;</span>, which);</span><br><span class="line">        buff[num % <span class="number">5</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printBuff</span>(<span class="string">&quot;Producer&quot;</span>);</span><br><span class="line"></span><br><span class="line">        full-&gt;<span class="built_in">V</span>();</span><br><span class="line">        mutex-&gt;<span class="built_in">V</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Consumer</span><span class="params">(<span class="type">int</span> which)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (num--) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread %d is trying to consume\n&quot;</span>, which);</span><br><span class="line">        full-&gt;<span class="built_in">P</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread %d is trying to get mutex\n&quot;</span>, which);</span><br><span class="line">        mutex-&gt;<span class="built_in">P</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread %d is comsuming\n&quot;</span>, which);</span><br><span class="line">        buff[num % <span class="number">5</span>] = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">printBuff</span>(<span class="string">&quot;Consumer&quot;</span>);</span><br><span class="line"></span><br><span class="line">        empty-&gt;<span class="built_in">V</span>();</span><br><span class="line">        mutex-&gt;<span class="built_in">V</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">ThreadTest5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DEBUG</span>(<span class="string">&#x27;t&#x27;</span>, <span class="string">&quot;Entering ThreadTest5\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Thread* prod = <span class="keyword">new</span> <span class="built_in">Thread</span>(<span class="string">&quot;Producer&quot;</span>);</span><br><span class="line">    Thread* cons = <span class="keyword">new</span> <span class="built_in">Thread</span>(<span class="string">&quot;Consumer&quot;</span>);</span><br><span class="line"></span><br><span class="line">    prod-&gt;<span class="built_in">Fork</span>(Producer, (<span class="type">void</span>*)<span class="number">1</span>);</span><br><span class="line">    cons-&gt;<span class="built_in">Fork</span>(Consumer, (<span class="type">void</span>*)<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果如下：</p>
<figure class="highlight shell"><figcaption><span>Shell输出结果</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line">root@b5500d28dd66:/nachos/nachos-3.4/code/threads# ./nachos -q 5</span><br><span class="line">No test specified.</span><br><span class="line">Thread 1 is trying to produce</span><br><span class="line">Thread 1 is trying to get mutex</span><br><span class="line">Thread 2 is trying to consume</span><br><span class="line">Thread 1 is producing</span><br><span class="line">===========Producer===========</span><br><span class="line">0 0 0 0 1 </span><br><span class="line">===========End===========</span><br><span class="line">Thread 1 is trying to produce</span><br><span class="line">Thread 1 is trying to get mutex</span><br><span class="line">Thread 1 is producing</span><br><span class="line">===========Producer===========</span><br><span class="line">0 0 0 1 1 </span><br><span class="line">===========End===========</span><br><span class="line">Thread 2 is trying to get mutex</span><br><span class="line">Thread 2 is comsuming</span><br><span class="line">===========Consumer===========</span><br><span class="line">0 0 0 1 -1 </span><br><span class="line">===========End===========</span><br><span class="line">Thread 1 is trying to produce</span><br><span class="line">Thread 1 is trying to get mutex</span><br><span class="line">Thread 1 is producing</span><br><span class="line">===========Producer===========</span><br><span class="line">0 0 1 1 -1 </span><br><span class="line">===========End===========</span><br><span class="line">Thread 1 is trying to produce</span><br><span class="line">Thread 1 is trying to get mutex</span><br><span class="line">Thread 1 is producing</span><br><span class="line">===========Producer===========</span><br><span class="line">0 1 1 1 -1 </span><br><span class="line">===========End===========</span><br><span class="line">Thread 1 is trying to produce</span><br><span class="line">Thread 1 is trying to get mutex</span><br><span class="line">Thread 1 is producing</span><br><span class="line">===========Producer===========</span><br><span class="line">1 1 1 1 -1 </span><br><span class="line">===========End===========</span><br><span class="line">Thread 1 is trying to produce</span><br><span class="line">Thread 1 is trying to get mutex</span><br><span class="line">Thread 1 is producing</span><br><span class="line">===========Producer===========</span><br><span class="line">1 1 1 1 1 </span><br><span class="line">===========End===========</span><br><span class="line">Thread 2 is trying to consume</span><br><span class="line">Thread 2 is trying to get mutex</span><br><span class="line">Thread 1 is trying to produce</span><br><span class="line">Thread 2 is comsuming</span><br><span class="line">===========Consumer===========</span><br><span class="line">1 1 1 -1 1 </span><br><span class="line">===========End===========</span><br><span class="line">Thread 2 is trying to consume</span><br><span class="line">Thread 2 is trying to get mutex</span><br><span class="line">Thread 2 is comsuming</span><br><span class="line">===========Consumer===========</span><br><span class="line">1 1 -1 -1 1 </span><br><span class="line">===========End===========</span><br><span class="line">Thread 1 is trying to get mutex</span><br><span class="line">Thread 2 is trying to consume</span><br><span class="line">Thread 2 is trying to get mutex</span><br><span class="line">Thread 2 is comsuming</span><br><span class="line">===========Consumer===========</span><br><span class="line">1 -1 -1 -1 1 </span><br><span class="line">===========End===========</span><br><span class="line">Thread 2 is trying to consume</span><br><span class="line">Thread 2 is trying to get mutex</span><br><span class="line">Thread 2 is comsuming</span><br><span class="line">===========Consumer===========</span><br><span class="line">-1 -1 -1 -1 1 </span><br><span class="line">===========End===========</span><br><span class="line">Thread 2 is trying to consume</span><br><span class="line">Thread 2 is trying to get mutex</span><br><span class="line">Thread 2 is comsuming</span><br><span class="line">===========Consumer===========</span><br><span class="line">-1 -1 -1 -1 -1 </span><br><span class="line">===========End===========</span><br><span class="line">Thread 2 is trying to consume</span><br><span class="line">Thread 1 is producing</span><br><span class="line">===========Producer===========</span><br><span class="line">-1 -1 -1 1 -1 </span><br><span class="line">===========End===========</span><br><span class="line">Thread 1 is trying to produce</span><br><span class="line">Thread 1 is trying to get mutex</span><br><span class="line">Thread 1 is producing</span><br><span class="line">===========Producer===========</span><br><span class="line">-1 -1 1 1 -1 </span><br><span class="line">===========End===========</span><br><span class="line">Thread 1 is trying to produce</span><br><span class="line">Thread 1 is trying to get mutex</span><br><span class="line">Thread 1 is producing</span><br><span class="line">===========Producer===========</span><br><span class="line">-1 1 1 1 -1 </span><br><span class="line">===========End===========</span><br><span class="line">Thread 1 is trying to produce</span><br><span class="line">Thread 1 is trying to get mutex</span><br><span class="line">Thread 2 is trying to get mutex</span><br><span class="line">Thread 1 is producing</span><br><span class="line">===========Producer===========</span><br><span class="line">1 1 1 1 -1 </span><br><span class="line">===========End===========</span><br><span class="line">Thread 2 is comsuming</span><br><span class="line">===========Consumer===========</span><br><span class="line">1 1 1 -1 -1 </span><br><span class="line">===========End===========</span><br><span class="line">Thread 2 is trying to consume</span><br><span class="line">Thread 2 is trying to get mutex</span><br><span class="line">Thread 2 is comsuming</span><br><span class="line">===========Consumer===========</span><br><span class="line">1 1 -1 -1 -1 </span><br><span class="line">===========End===========</span><br><span class="line">Thread 2 is trying to consume</span><br><span class="line">Thread 2 is trying to get mutex</span><br><span class="line">Thread 2 is comsuming</span><br><span class="line">===========Consumer===========</span><br><span class="line">1 -1 -1 -1 -1 </span><br><span class="line">===========End===========</span><br><span class="line">Thread 2 is trying to consume</span><br><span class="line">Thread 2 is trying to get mutex</span><br><span class="line">Thread 2 is comsuming</span><br><span class="line">===========Consumer===========</span><br><span class="line">-1 -1 -1 -1 -1 </span><br><span class="line">===========End===========</span><br><span class="line">No threads ready or runnable, and no pending interrupts.</span><br><span class="line">Assuming the program completed.</span><br><span class="line">Machine halting!</span><br><span class="line"></span><br><span class="line">Ticks: total 940, idle 20, system 920, user 0</span><br><span class="line">Disk I/O: reads 0, writes 0</span><br><span class="line">Console I/O: reads 0, writes 0</span><br><span class="line">Paging: faults 0</span><br><span class="line">Network I/O: packets received 0, sent 0</span><br><span class="line"></span><br><span class="line">Cleaning up...</span><br></pre></td></tr></table></figure>

<h4 id="生产者-消费者问题（条件变量实现）"><a href="#生产者-消费者问题（条件变量实现）" class="headerlink" title="生产者-消费者问题（条件变量实现）"></a>生产者-消费者问题（条件变量实现）</h4><p>设置一个互斥锁CondLock_PC_mutex来实现对条件变量以及临界区的互斥操作。因此对生产者和消费者分别设置一个条件变量用于记录各自的阻塞队列。最后用两个变量分别标记缓冲区被使用的空间大小，以及缓冲区的最大限度。</p>
<p>同样，生产者和消费者的实现上比较类似，因此以生产者举例。设置了共10个生产任务及5个缓冲区大小。生产者首先获取互斥锁来访问缓冲区，然后用while语句判断是否有空闲空间以供生产。如果没有则将自己置入生产者条件变量的等待队列；如果有则生产一个产品，最后唤醒消费者并释放锁。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 条件变量</span></span><br><span class="line">Lock * CondLock_PC_mutex = <span class="keyword">new</span> <span class="built_in">Lock</span>(<span class="string">&quot;CondLock_PC_mutex&quot;</span>);  <span class="comment">// 互斥锁</span></span><br><span class="line">Condition * Cond_PC_p = <span class="keyword">new</span> <span class="built_in">Condition</span>(<span class="string">&quot;Cond_PC_p&quot;</span>);  <span class="comment">// 生产者条件变量</span></span><br><span class="line">Condition * Cond_PC_c = <span class="keyword">new</span> <span class="built_in">Condition</span>(<span class="string">&quot;Cond_PC_c&quot;</span>);  <span class="comment">// 消费者条件变量</span></span><br><span class="line"><span class="type">int</span> buffSize = <span class="number">0</span>;  <span class="comment">// 互斥缓冲区</span></span><br><span class="line"><span class="type">int</span> maxBuffSize = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Producer</span><span class="params">(<span class="type">int</span> which)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (num--) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread %d is trying to get lock\n&quot;</span>, which);</span><br><span class="line">        CondLock_PC_mutex-&gt;<span class="built_in">Acquire</span>();</span><br><span class="line">        <span class="keyword">while</span> (buffSize &gt;= maxBuffSize) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Thread %d is waiting\n&quot;</span>, which);</span><br><span class="line">            Cond_PC_p-&gt;<span class="built_in">Wait</span>(CondLock_PC_mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread %d is producing\n&quot;</span>, which);</span><br><span class="line">        buffSize++;</span><br><span class="line">        Cond_PC_c-&gt;<span class="built_in">Signal</span>(CondLock_PC_mutex);</span><br><span class="line">        CondLock_PC_mutex-&gt;<span class="built_in">Release</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Consumer</span><span class="params">(<span class="type">int</span> which)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (num--) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread %d is trying to get lock\n&quot;</span>, which);</span><br><span class="line">        CondLock_PC_mutex-&gt;<span class="built_in">Acquire</span>();</span><br><span class="line">        <span class="keyword">while</span> (buffSize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Thread %d is waiting\n&quot;</span>, which);</span><br><span class="line">            Cond_PC_c-&gt;<span class="built_in">Wait</span>(CondLock_PC_mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread %d is consuming\n&quot;</span>, which);</span><br><span class="line">        buffSize--;</span><br><span class="line">        Cond_PC_p-&gt;<span class="built_in">Signal</span>(CondLock_PC_mutex);</span><br><span class="line">        CondLock_PC_mutex-&gt;<span class="built_in">Release</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">ThreadTest6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DEBUG</span>(<span class="string">&#x27;t&#x27;</span>, <span class="string">&quot;Entering ThreadTest5\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Thread* prod = <span class="keyword">new</span> <span class="built_in">Thread</span>(<span class="string">&quot;Producer&quot;</span>);</span><br><span class="line">    Thread* cons = <span class="keyword">new</span> <span class="built_in">Thread</span>(<span class="string">&quot;Consumer&quot;</span>);</span><br><span class="line"></span><br><span class="line">    prod-&gt;<span class="built_in">Fork</span>(Producer, (<span class="type">void</span>*)<span class="number">1</span>);</span><br><span class="line">    cons-&gt;<span class="built_in">Fork</span>(Consumer, (<span class="type">void</span>*)<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果如下：</p>
<figure class="highlight shell"><figcaption><span>Shell输出结果</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">root@b5500d28dd66:/nachos/nachos-3.4/code/threads# ./nachos -q 5 </span><br><span class="line">No test specified.</span><br><span class="line">Thread 1 is trying to get lock</span><br><span class="line">Thread 1 is producing</span><br><span class="line">Thread 2 is trying to get lock</span><br><span class="line">Thread 1 is trying to get lock</span><br><span class="line">Thread 1 is producing</span><br><span class="line">Thread 1 is trying to get lock</span><br><span class="line">Thread 1 is producing</span><br><span class="line">Thread 1 is trying to get lock</span><br><span class="line">Thread 1 is producing</span><br><span class="line">Thread 1 is trying to get lock</span><br><span class="line">Thread 1 is producing</span><br><span class="line">Thread 1 is trying to get lock</span><br><span class="line">Thread 1 is waiting</span><br><span class="line">Thread 2 is consuming</span><br><span class="line">Thread 1 is producing</span><br><span class="line">Thread 1 is trying to get lock</span><br><span class="line">Thread 1 is waiting</span><br><span class="line">Thread 2 is trying to get lock</span><br><span class="line">Thread 2 is consuming</span><br><span class="line">Thread 2 is trying to get lock</span><br><span class="line">Thread 2 is consuming</span><br><span class="line">Thread 2 is trying to get lock</span><br><span class="line">Thread 2 is consuming</span><br><span class="line">Thread 2 is trying to get lock</span><br><span class="line">Thread 2 is consuming</span><br><span class="line">Thread 2 is trying to get lock</span><br><span class="line">Thread 2 is consuming</span><br><span class="line">Thread 2 is trying to get lock</span><br><span class="line">Thread 2 is waiting</span><br><span class="line">Thread 1 is producing</span><br><span class="line">Thread 1 is trying to get lock</span><br><span class="line">Thread 1 is producing</span><br><span class="line">Thread 1 is trying to get lock</span><br><span class="line">Thread 1 is producing</span><br><span class="line">Thread 1 is trying to get lock</span><br><span class="line">Thread 1 is producing</span><br><span class="line">Thread 2 is consuming</span><br><span class="line">Thread 2 is trying to get lock</span><br><span class="line">Thread 2 is consuming</span><br><span class="line">Thread 2 is trying to get lock</span><br><span class="line">Thread 2 is consuming</span><br><span class="line">Thread 2 is trying to get lock</span><br><span class="line">Thread 2 is consuming</span><br><span class="line">No threads ready or runnable, and no pending interrupts.</span><br><span class="line">Assuming the program completed.</span><br><span class="line">Machine halting!</span><br><span class="line"></span><br><span class="line">Ticks: total 760, idle 20, system 740, user 0</span><br><span class="line">Disk I/O: reads 0, writes 0</span><br><span class="line">Console I/O: reads 0, writes 0</span><br><span class="line">Paging: faults 0</span><br><span class="line">Network I/O: packets received 0, sent 0</span><br><span class="line"></span><br><span class="line">Cleaning up...</span><br></pre></td></tr></table></figure>

<h3 id="Challenge-1-实现barrier"><a href="#Challenge-1-实现barrier" class="headerlink" title="Challenge 1  实现barrier"></a>Challenge 1  实现barrier</h3><blockquote>
<p>可以使用Nachos 提供的同步互斥机制（如条件变量）来实现barrier，使得当且仅当若干个线程同时到达某一点时方可继续执行。</p>
</blockquote>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>若要满足“当且仅当若干个线程同时到达某一点时方可继续执行”，那么可以考虑用到条件变量中的<em>Broadcast</em>方法。然后增设一个变量来统计进入到条件变量等待队列中的线程数，当所有线程抵达barrier所设的点时，也即所有线程都进入到了等待队列中，此时将所有线程同时唤醒。</p>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>采取新建一个Barrier类的方式来实现。首先在<em>threads&#x2F;synch.h</em>中创建Barrier类的基本结构如下。Barrier主要包含了4个属性，锁lock用于条件变量的操作，条件变量用于记录不满足条件时等待的线程以及后续的唤醒操作，size用于记录满足Barrier要求的线程数，cur_size记录当前抵达Barrier时阻塞的线程数。</p>
<p>Barrier除了基本的构造&#x2F;析构函数外，仅有一个操作方法<em>Set</em>用于在某个点设置barrier（即在需要放置barrier的点调用<em>Set</em>函数即可）。<em>Set</em>的实现方式，首先获取锁保证临界区的互斥操作，然后将抵达该点的线程计数器增加，接着判断是否满足了释放所有线程的条件size。如果满足则调用条件变量的<em>Broadcast</em>方法唤醒所有的线程；如果不满足则将当前线程放入条件变量的阻塞队列中。这样就实现了Barrier的基本功能。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * threads/synch.h</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Barrier</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Barrier</span>(<span class="type">char</span>* debugName, <span class="type">int</span> initSize);</span><br><span class="line">    ~<span class="built_in">Barrier</span>();</span><br><span class="line">    <span class="function"><span class="type">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> (name); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Lock* lock;</span><br><span class="line">    Condition* condition;</span><br><span class="line">    <span class="type">char</span>* name;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span> cur_size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * threads/synch.cc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Barrier::<span class="built_in">Barrier</span>(<span class="type">char</span> *debugName, <span class="type">int</span> initSize) &#123;</span><br><span class="line">    size = initSize;</span><br><span class="line">    lock = <span class="keyword">new</span> <span class="built_in">Lock</span>(<span class="string">&quot;Barrier Lock&quot;</span>);</span><br><span class="line">    name = debugName;</span><br><span class="line">    condition = <span class="keyword">new</span> <span class="built_in">Condition</span>(<span class="string">&quot;Barrier Condition&quot;</span>);</span><br><span class="line">    cur_size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Barrier::~<span class="built_in">Barrier</span>() &#123;</span><br><span class="line">    <span class="keyword">delete</span> lock;</span><br><span class="line">    <span class="keyword">delete</span> condition;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Barrier::Set</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock-&gt;<span class="built_in">Acquire</span>();</span><br><span class="line">    cur_size++;</span><br><span class="line">    <span class="keyword">if</span> (cur_size &gt;= size) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread %s, current number %d, needed number %d, do Broadcast\n&quot;</span>,</span><br><span class="line">               currentThread-&gt;<span class="built_in">getName</span>(), cur_size, size);</span><br><span class="line">        condition-&gt;<span class="built_in">Broadcast</span>(lock);</span><br><span class="line">        lock-&gt;<span class="built_in">Release</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread %s, current number %d, needed number %d, do Wait\n&quot;</span>,</span><br><span class="line">               currentThread-&gt;<span class="built_in">getName</span>(), cur_size, size);</span><br><span class="line">        condition-&gt;<span class="built_in">Wait</span>(lock);</span><br><span class="line">        lock-&gt;<span class="built_in">Release</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread %s continue run\n&quot;</span>,</span><br><span class="line">           currentThread-&gt;<span class="built_in">getName</span>(), cur_size, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后编写测试函数，在两个线程中分别对Barrier_x和Barrier_y赋值，然后进行计算。这就意味着仅当两个线程同时赋值结束之后才能获得正确的运算结果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> Barrier_x = <span class="number">0</span>, Barrier_y = <span class="number">0</span>;</span><br><span class="line">Barrier* barrier = <span class="keyword">new</span> <span class="built_in">Barrier</span>(<span class="string">&quot;Barrier&quot;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BarrierFunc_1</span><span class="params">(<span class="type">int</span> which)</span> </span>&#123;</span><br><span class="line">    Barrier_x = <span class="number">10</span>;</span><br><span class="line">    barrier-&gt;<span class="built_in">Set</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;BarrierFunc_1 do \&#x27;x * y\&#x27;, get %d\n&quot;</span>, Barrier_x * Barrier_y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BarrierFunc_2</span><span class="params">(<span class="type">int</span> which)</span> </span>&#123;</span><br><span class="line">    Barrier_y = <span class="number">3</span>;</span><br><span class="line">    barrier-&gt;<span class="built_in">Set</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;BarrierFunc_2 do \&#x27;x + y\&#x27;, get %d\n&quot;</span>, Barrier_x + Barrier_y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">ThreadTest7</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DEBUG</span>(<span class="string">&#x27;t&#x27;</span>, <span class="string">&quot;Entering ThreadTest5\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Thread* thread_1 = <span class="keyword">new</span> <span class="built_in">Thread</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    Thread* thread_2 = <span class="keyword">new</span> <span class="built_in">Thread</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    thread_1-&gt;<span class="built_in">Fork</span>(BarrierFunc_1, (<span class="type">void</span>*)<span class="number">1</span>);</span><br><span class="line">    thread_2-&gt;<span class="built_in">Fork</span>(BarrierFunc_2, (<span class="type">void</span>*)<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果如下：</p>
<figure class="highlight shell"><figcaption><span>Shell输出结果</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">root@b5500d28dd66:/nachos/nachos-3.4/code/threads# ./nachos -q 7 </span><br><span class="line">Thread 1, current number 1, needed number 2, do Wait</span><br><span class="line">Thread 2, current number 2, needed number 2, do Broadcast</span><br><span class="line">Thread 2 continue run</span><br><span class="line">BarrierFunc_2 do &#x27;x + y&#x27;, get 13</span><br><span class="line">Thread 1 continue run</span><br><span class="line">BarrierFunc_1 do &#x27;x * y&#x27;, get 30</span><br><span class="line">No threads ready or runnable, and no pending interrupts.</span><br><span class="line">Assuming the program completed.</span><br><span class="line">Machine halting!</span><br><span class="line"></span><br><span class="line">Ticks: total 140, idle 10, system 130, user 0</span><br><span class="line">Disk I/O: reads 0, writes 0</span><br><span class="line">Console I/O: reads 0, writes 0</span><br><span class="line">Paging: faults 0</span><br><span class="line">Network I/O: packets received 0, sent 0</span><br><span class="line"></span><br><span class="line">Cleaning up...</span><br></pre></td></tr></table></figure>

<h3 id="Challenge-2-实现read-x2F-write-lock"><a href="#Challenge-2-实现read-x2F-write-lock" class="headerlink" title="Challenge 2 实现read&#x2F;write lock"></a>Challenge 2 实现read&#x2F;write lock</h3><blockquote>
<p>基于Nachos提供的lock(synch.h和synch.cc)，实现read&#x2F;write lock。使得若干线程可以同时读取某共享数据区内的数据，但是在某一特定的时刻，只有一个线程可以向该共享数据区写入数据。</p>
</blockquote>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>读写锁是计算机程序的并发控制的一种同步机制，也称“共享-互斥锁”、多读者-单写者锁。 用于解决读写问题。读操作可并发重入，写操作是互斥的。</p>
<p>互斥原则：</p>
<ul>
<li>读-读能共存，</li>
<li>读-写不能共存，</li>
<li>写-写不能共存。</li>
</ul>
<h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><p>利用条件变量实现读写锁。使用一个计数器refCount来标记当前锁的状态，当该值为-1时表示有1个写者正在写；当该值为0时表示锁未使用；当该值为正数时表示有n个读者正在读。为保证写写互斥，refCount负值仅能为-1。readCond条件变量记录当有读者正在读时，写者的等待队列；writeCond条件变量记录当有写者正在写时，读者的等待队列。最后两个变量readWaiters和writeWaiters分别记录读写者等待的数量，以及用于在释放锁时使用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReadWriteLock</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ReadWriteLock</span>(<span class="type">char</span>* debugName);</span><br><span class="line">    ~<span class="built_in">ReadWriteLock</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ReadLock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">WriteLock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Unlock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* name;</span><br><span class="line">    <span class="type">int</span> refCount;  <span class="comment">// -1表示有写者，0表示无人加锁，正数表示读者个数</span></span><br><span class="line">    Lock* rwLock;</span><br><span class="line">    Condition* readCond;</span><br><span class="line">    Condition* writeCond;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> readWaiters;</span><br><span class="line">    <span class="type">int</span> writeWaiters;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于读锁的实现主要是根据refCount的值判断是否有写者正在写，如果有则进入等待队列；如果没有则将refCount的值增加，且获取锁。因此读锁的可重入就是通过refCount的判断来实现的，读者仅会因为有写者正在写而阻塞。</p>
<p>这里要注意的是，while不能用if来判断，理由与P操作中的while类似。首先，<em>Wait</em>操作会释放锁rwLock，然后等待readCond执行<em>Signal</em>，最后重新操作条件变量时，再对rwLock加锁。这样就会存在一种情况，在当前读线程从被<em>Signal</em>唤醒之后，还没来得及对rwLock进行加锁时，另外一个线程被换上CPU来获取写锁，此时refCount为0，因此导致refcount变成了-1。如果不重新对refcount进行判断就会导致读者写者同时获取锁。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ReadWriteLock::ReadLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rwLock-&gt;<span class="built_in">Acquire</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread %s is tring to get ReadLock, readerWaiters %d, writeWaiters %d, refCount %d\n&quot;</span>,</span><br><span class="line">           currentThread-&gt;<span class="built_in">getName</span>(), readWaiters, writeWaiters, refCount);</span><br><span class="line">    <span class="keyword">while</span> (refCount &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        readWaiters++;</span><br><span class="line">        readCond-&gt;<span class="built_in">Wait</span>(rwLock);</span><br><span class="line">        readWaiters--;</span><br><span class="line">    &#125;</span><br><span class="line">    refCount++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread %s get ReadLock, readerWaiters %d, writeWaiters %d, refCount %d\n&quot;</span>,</span><br><span class="line">           currentThread-&gt;<span class="built_in">getName</span>(), readWaiters, writeWaiters, refCount);</span><br><span class="line">    rwLock-&gt;<span class="built_in">Release</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写锁的实现方式与读锁类似。主要区别在于为了保证写写互斥、读写互斥，要求refCount的值为0，即仅当没有任何线程获取到锁时，才能加写锁。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ReadWriteLock::WriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rwLock-&gt;<span class="built_in">Acquire</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread %s is tring to get WriteLock, readerWaiters %d, writeWaiters %d, refCount %d\n&quot;</span>,</span><br><span class="line">           currentThread-&gt;<span class="built_in">getName</span>(), readWaiters, writeWaiters, refCount);</span><br><span class="line">    <span class="keyword">while</span> (refCount != <span class="number">0</span>) &#123;</span><br><span class="line">        writeWaiters++;</span><br><span class="line">        writeCond-&gt;<span class="built_in">Wait</span>(rwLock);</span><br><span class="line">        writeWaiters--;</span><br><span class="line">    &#125;</span><br><span class="line">    refCount = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread %s get WriteLock, readerWaiters %d, writeWaiters %d, refCount %d\n&quot;</span>,</span><br><span class="line">           currentThread-&gt;<span class="built_in">getName</span>(), readWaiters, writeWaiters, refCount);</span><br><span class="line">    rwLock-&gt;<span class="built_in">Release</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后是解锁<em>Unlock</em>的实现。如果是写者释放锁，则直接将refCount置0；如果是读者释放锁，则将refCount减1。改动完了refCount之后，再进一步判断是否所有线程都释放了锁。当存在等待的写者时，则用<em>Signal</em>唤醒一个写者；当存在等待的读者时，则用<em>Broadcast</em>唤醒所有读者（因为读锁是可重入的）。</p>
<p><strong>在该实现下，如果有写者进入等待队列，但在这之后运行新的读者获得锁，因此这是一种读优先的实现。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ReadWriteLock::Unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ASSERT</span>(refCount != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    rwLock-&gt;<span class="built_in">Acquire</span>();</span><br><span class="line">    <span class="keyword">if</span> (refCount == <span class="number">-1</span>) &#123;</span><br><span class="line">        refCount = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        refCount--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (refCount == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (writeWaiters &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            writeCond-&gt;<span class="built_in">Signal</span>(rwLock);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readWaiters &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            readCond-&gt;<span class="built_in">Broadcast</span>(rwLock);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread %s unlocked, readerWaiters %d, writeWaiters %d, refCount %d\n&quot;</span>,</span><br><span class="line">           currentThread-&gt;<span class="built_in">getName</span>(), readWaiters, writeWaiters, refCount);</span><br><span class="line">    rwLock-&gt;<span class="built_in">Release</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后编写测试函数如下。编写相应的测试函数。使用一个整数来模拟共享文件。读&#x2F;写函数类似，读操作仅获取sharedFile的值，写操作会对该值+1。为了能见到读写锁的互斥以及写优先策略的效果，在释放锁前和释放锁后均让线程执行Yield放弃CPU。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">ReadWriteLock* readWriteLock = <span class="keyword">new</span> <span class="built_in">ReadWriteLock</span>(<span class="string">&quot;ReadWriteLock Test&quot;</span>);</span><br><span class="line"><span class="type">int</span> sharedFile = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_read</span><span class="params">(<span class="type">int</span> which)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (num--) &#123;</span><br><span class="line">        readWriteLock-&gt;<span class="built_in">ReadLock</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread %s is reading, sharedFile value %d\n&quot;</span>, currentThread-&gt;<span class="built_in">getName</span>(), sharedFile);</span><br><span class="line">        currentThread-&gt;<span class="built_in">Yield</span>();</span><br><span class="line">        readWriteLock-&gt;<span class="built_in">Unlock</span>();</span><br><span class="line">        currentThread-&gt;<span class="built_in">Yield</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_write</span><span class="params">(<span class="type">int</span> which)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">while</span> (num--) &#123;</span><br><span class="line">        readWriteLock-&gt;<span class="built_in">WriteLock</span>();</span><br><span class="line">        sharedFile++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread %s is writing, sharedFile value %d\n&quot;</span>, currentThread-&gt;<span class="built_in">getName</span>(), sharedFile);</span><br><span class="line">        currentThread-&gt;<span class="built_in">Yield</span>();</span><br><span class="line">        readWriteLock-&gt;<span class="built_in">Unlock</span>();</span><br><span class="line">        currentThread-&gt;<span class="built_in">Yield</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">ThreadTest8</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DEBUG</span>(<span class="string">&#x27;t&#x27;</span>, <span class="string">&quot;Entering ThreadTest5\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Thread* read_1 = <span class="keyword">new</span> <span class="built_in">Thread</span>(<span class="string">&quot;Read_1&quot;</span>);</span><br><span class="line">    Thread* read_2 = <span class="keyword">new</span> <span class="built_in">Thread</span>(<span class="string">&quot;Read_2&quot;</span>);</span><br><span class="line">    Thread* read_3 = <span class="keyword">new</span> <span class="built_in">Thread</span>(<span class="string">&quot;Read_3&quot;</span>);</span><br><span class="line">    Thread* write_1 = <span class="keyword">new</span> <span class="built_in">Thread</span>(<span class="string">&quot;Write_1&quot;</span>);</span><br><span class="line">    Thread* write_2 = <span class="keyword">new</span> <span class="built_in">Thread</span>(<span class="string">&quot;Write_2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    write_1-&gt;<span class="built_in">Fork</span>(do_write, (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line">    read_1-&gt;<span class="built_in">Fork</span>(do_read, (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line">    read_2-&gt;<span class="built_in">Fork</span>(do_read, (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line">    write_2-&gt;<span class="built_in">Fork</span>(do_write, (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line">    read_3-&gt;<span class="built_in">Fork</span>(do_read, (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后分别创建了3个读线程，2个写线程进行测试，结果如下。可以看到当有写着在写时，其他写者和读者加入到等待队列。然后该写者写完时，新的写者优先获得锁。直到等待队列中没有写者时，读者才开始读。多个线程同时获得了读锁。</p>
<figure class="highlight shell"><figcaption><span>Shell执行结果</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">root@b5500d28dd66:/nachos/nachos-3.4/code/threads# ./nachos -q 8</span><br><span class="line">Thread Write_1 is tring to get WriteLock, readerWaiters 0, writeWaiters 0, refCount 0</span><br><span class="line">Thread Write_1 get WriteLock, readerWaiters 0, writeWaiters 0, refCount -1</span><br><span class="line">Thread Write_1 is writing, sharedFile value 1</span><br><span class="line">Thread Read_1 is tring to get ReadLock, readerWaiters 0, writeWaiters 0, refCount -1</span><br><span class="line">Thread Read_2 is tring to get ReadLock, readerWaiters 1, writeWaiters 0, refCount -1</span><br><span class="line">Thread Write_2 is tring to get WriteLock, readerWaiters 2, writeWaiters 0, refCount -1</span><br><span class="line">Thread Read_3 is tring to get ReadLock, readerWaiters 2, writeWaiters 1, refCount -1</span><br><span class="line">Thread Write_1 unlocked, readerWaiters 3, writeWaiters 1, refCount 0</span><br><span class="line">Thread Write_2 get WriteLock, readerWaiters 3, writeWaiters 0, refCount -1</span><br><span class="line">Thread Write_2 is writing, sharedFile value 2</span><br><span class="line">Thread Write_1 is tring to get WriteLock, readerWaiters 3, writeWaiters 0, refCount -1</span><br><span class="line">Thread Write_2 unlocked, readerWaiters 3, writeWaiters 1, refCount 0</span><br><span class="line">Thread Write_1 get WriteLock, readerWaiters 3, writeWaiters 0, refCount -1</span><br><span class="line">Thread Write_1 is writing, sharedFile value 3</span><br><span class="line">Thread Write_2 is tring to get WriteLock, readerWaiters 3, writeWaiters 0, refCount -1</span><br><span class="line">Thread Write_1 unlocked, readerWaiters 3, writeWaiters 1, refCount 0</span><br><span class="line">Thread Write_2 get WriteLock, readerWaiters 3, writeWaiters 0, refCount -1</span><br><span class="line">Thread Write_2 is writing, sharedFile value 4</span><br><span class="line">Thread Write_1 is tring to get WriteLock, readerWaiters 3, writeWaiters 0, refCount -1</span><br><span class="line">Thread Write_2 unlocked, readerWaiters 3, writeWaiters 1, refCount 0</span><br><span class="line">Thread Write_1 get WriteLock, readerWaiters 3, writeWaiters 0, refCount -1</span><br><span class="line">Thread Write_1 is writing, sharedFile value 5</span><br><span class="line">Thread Write_2 is tring to get WriteLock, readerWaiters 3, writeWaiters 0, refCount -1</span><br><span class="line">Thread Write_1 unlocked, readerWaiters 3, writeWaiters 1, refCount 0</span><br><span class="line">Thread Write_2 get WriteLock, readerWaiters 3, writeWaiters 0, refCount -1</span><br><span class="line">Thread Write_2 is writing, sharedFile value 6</span><br><span class="line">Thread Write_2 unlocked, readerWaiters 3, writeWaiters 0, refCount 0</span><br><span class="line">Thread Read_1 get ReadLock, readerWaiters 2, writeWaiters 0, refCount 1</span><br><span class="line">Thread Read_2 get ReadLock, readerWaiters 1, writeWaiters 0, refCount 2</span><br><span class="line">Thread Read_3 get ReadLock, readerWaiters 0, writeWaiters 0, refCount 3</span><br><span class="line">Thread Read_1 is reading, sharedFile value 6</span><br><span class="line">Thread Read_2 is reading, sharedFile value 6</span><br><span class="line">Thread Read_3 is reading, sharedFile value 6</span><br><span class="line">Thread Read_1 unlocked, readerWaiters 0, writeWaiters 0, refCount 2</span><br><span class="line">Thread Read_2 unlocked, readerWaiters 0, writeWaiters 0, refCount 1</span><br><span class="line">Thread Read_3 unlocked, readerWaiters 0, writeWaiters 0, refCount 0</span><br><span class="line">Thread Read_1 is tring to get ReadLock, readerWaiters 0, writeWaiters 0, refCount 0</span><br><span class="line">Thread Read_1 get ReadLock, readerWaiters 0, writeWaiters 0, refCount 1</span><br><span class="line">Thread Read_1 is reading, sharedFile value 6</span><br><span class="line">Thread Read_2 is tring to get ReadLock, readerWaiters 0, writeWaiters 0, refCount 1</span><br><span class="line">Thread Read_2 get ReadLock, readerWaiters 0, writeWaiters 0, refCount 2</span><br><span class="line">Thread Read_3 is tring to get ReadLock, readerWaiters 0, writeWaiters 0, refCount 2</span><br><span class="line">Thread Read_3 get ReadLock, readerWaiters 0, writeWaiters 0, refCount 3</span><br><span class="line">Thread Read_3 is reading, sharedFile value 6</span><br><span class="line">Thread Read_2 is reading, sharedFile value 6</span><br><span class="line">Thread Read_3 unlocked, readerWaiters 0, writeWaiters 0, refCount 2</span><br><span class="line">Thread Read_2 unlocked, readerWaiters 0, writeWaiters 0, refCount 1</span><br><span class="line">Thread Read_1 unlocked, readerWaiters 0, writeWaiters 0, refCount 0</span><br><span class="line">No threads ready or runnable, and no pending interrupts.</span><br><span class="line">Assuming the program completed.</span><br><span class="line">Machine halting!</span><br><span class="line"></span><br><span class="line">Ticks: total 1100, idle 10, system 1090, user 0</span><br><span class="line">Disk I/O: reads 0, writes 0</span><br><span class="line">Console I/O: reads 0, writes 0</span><br><span class="line">Paging: faults 0</span><br><span class="line">Network I/O: packets received 0, sent 0</span><br><span class="line"></span><br><span class="line">Cleaning up...</span><br></pre></td></tr></table></figure>

<h3 id="Challenge-3-研究Linux的kfifo机制是否可以移植到Nachos上作为一个新的同步模块"><a href="#Challenge-3-研究Linux的kfifo机制是否可以移植到Nachos上作为一个新的同步模块" class="headerlink" title="Challenge 3  研究Linux的kfifo机制是否可以移植到Nachos上作为一个新的同步模块"></a>Challenge 3  研究Linux的kfifo机制是否可以移植到Nachos上作为一个新的同步模块</h3><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>kfifo是一个Linux内核使用的环形缓冲区。该缓冲区要求一次仅能有一个写进程和一个读进程在同时工作。其缓冲区如下图，in表示写者写入的位置，out表示读者开始读的位置。因为这种类似与生产者消费者的工作模式（即只要生产了数据，即可立即消费数据），同时缓冲区的数据满足FIFO的特性，所以可以使用一个队列来实现。</p>
<img src="/2020/11/22/Nachos-Lab03-%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/KFifo_buffer_1.png" class="" title="KFIFO Buffer 1">

<p>从Linux内核中kfifo的实现方式可以看到，需要有一个存储数据的共享缓冲区、该缓冲区的大小（以2的幂次较好，<code>in % size</code> 可以转化为<code> in &amp; (size – 1)</code>）、in添加数据的起始游标、out输出数据的起始游标、以及一个自旋锁（用于防止重入）。</p>
<figure class="highlight c"><figcaption><span>Linux中kfifo的实现</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kfifo</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *buffer;     <span class="comment">/* the buffer holding the data */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> size;         <span class="comment">/* the size of the allocated buffer */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> in;           <span class="comment">/* data is added at offset (in % size) */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> out;          <span class="comment">/* data is extracted from off. (out % size) */</span></span><br><span class="line">    <span class="type">spinlock_t</span> *lock;          <span class="comment">/* protects concurrent modifications */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>kfifo的巧妙之处在于in和out定义为无符号类型，在put和get时，in和out都是增加，当达到最大值时，产生溢出，使得从0开始，进行循环使用。如下图，当in溢出后，in的位置比out低，但是缓冲区数据的长度仍是<code>in - out</code>。</p>
<img src="/2020/11/22/Nachos-Lab03-%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/KFifo_buffer_2.png" class="" title="KFIFO Buffer 2">

<p>另外kfifo还使用了内存屏障（smp_mb、smp_wmb、smp_rmb），用于来处理kfifo中读&#x2F;写和out&#x2F;in指针更新之间可能存在的内存乱序访问的情况。但是在单CPU的情况下，多线程执行不存在运行时内存乱序访问，因此对于只支持单CPU的Nachos来说，不需要考虑实现内存屏障。</p>
<h4 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h4><p>首先在<em>machine&#x2F;sysdep.h</em>中声明Memcpy的函数，然后在<em>machine&#x2F;sysdep.cc</em>中实现。该函数用于kfifo中缓冲区的写入和读取。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * machine/sysdep.h</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 内存拷贝函数</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span>* <span class="title">Memcpy</span><span class="params">(<span class="type">void</span> *str1, <span class="type">const</span> <span class="type">void</span> *str2, <span class="type">unsigned</span> <span class="type">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * machine/sysdep.cc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">Memcpy</span><span class="params">(<span class="type">void</span> *str1, <span class="type">const</span> <span class="type">void</span> *str2, <span class="type">unsigned</span> <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">memcpy</span>(str1, str2, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后KFifo类的声明如下，包含基本的缓冲区buffer，缓冲区大小size，输入游标in，输出游标out，输入函数<em>Put</em>，输出函数<em>Get</em>，以及缓冲区使用空间查询函数<em>BufferUsedSize</em>。</p>
<p>为了简便，这里删去了Linux中用到的自旋锁，自旋锁是为了保证同一时刻最多有一个读者和一个写者在操作KFifo。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * threads/synch.h</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">KFifo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">KFifo</span>(<span class="type">char</span> * debugname, <span class="type">unsigned</span> <span class="type">int</span> bufsize);</span><br><span class="line">    ~<span class="built_in">KFifo</span>();</span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">Put</span><span class="params">(<span class="type">char</span> * inBuff, <span class="type">int</span> len)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">Get</span><span class="params">(<span class="type">char</span> * oufBuff, <span class="type">int</span> len)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">BufferUsedSize</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> * name;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> * buffer;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> size;  <span class="comment">// 缓冲区大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> in;  <span class="comment">// 输入的位置</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> out;  <span class="comment">// 输出的位置</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接下来是其主要功能的实现，位于<em>threads&#x2F;synch.cc</em>。对于构造函数，在这里除了基本的初始化之外，最重要的是将缓冲区的大小向上取整，为了后续计算的方便。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">KFifo::<span class="built_in">KFifo</span>(<span class="type">char</span> *debugname, <span class="type">unsigned</span> <span class="type">int</span> bufSize) &#123;</span><br><span class="line">    name = debugname;</span><br><span class="line">    <span class="built_in">ASSERT</span>(bufSize &lt;= (<span class="number">1</span> &lt;&lt; <span class="number">31</span>));  <span class="comment">// 无法表示 1 &lt;&lt; 32 的整数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> upSize = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (upSize &lt; bufSize) &#123; upSize = upSize &lt;&lt; <span class="number">1</span>; &#125;</span><br><span class="line">    size = upSize;  <span class="comment">// 大小向上取2的倍数，好处为对size的取模运算可以转化为与运算</span></span><br><span class="line">    buffer = <span class="keyword">new</span> <span class="type">char</span>[size];</span><br><span class="line">    in = <span class="number">0</span>;</span><br><span class="line">    out = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">KFifo::~<span class="built_in">KFifo</span>() &#123;</span><br><span class="line">    <span class="keyword">delete</span> buffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Put函数的实现。首先是计算可以访问的空间，将传入数据的长度len和缓冲区的剩余空间<code>size - in + out</code>取较小值，即为缓冲区能够写入的数据大小。为了模拟循环队列，先尝试将输入从in一直写入到buffer（buffer自身是线性存储）的末尾；如果仍有数据要写入，则继续从buffer的头部开始写入。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">KFifo::Put</span><span class="params">(<span class="type">char</span> *inBuff, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> l;  <span class="comment">// 从in到缓冲区末尾的长度</span></span><br><span class="line"></span><br><span class="line">    len = <span class="built_in">min</span>(len, size - in + out);  <span class="comment">// 空闲空间</span></span><br><span class="line">    <span class="comment">// 先将数据从in写到buffer的末尾</span></span><br><span class="line">    l = <span class="built_in">min</span>(len, size - (in &amp; (size - <span class="number">1</span>)));</span><br><span class="line">    <span class="built_in">Memcpy</span>(buffer + (in &amp; (size - <span class="number">1</span>)), inBuff, l);</span><br><span class="line">    <span class="comment">// 然后将剩余部分写在buffer的头部</span></span><br><span class="line">    <span class="built_in">Memcpy</span>(buffer, buffer + l, len - l);</span><br><span class="line">    in += len;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Get函数的实现与Put类似。首先是计算可以读取的数据长度，将传入待读取长度len和缓冲区的数据长度<code>in - out</code>取较小值，即为缓冲区能够写入的数据大小。同样为了模拟循环队列，先尝试将输出从out一直读取到buffer（buffer自身是线性存储）的末尾；如果仍有数据要读取，则考虑继续从buffer的头部开始读取。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">KFifo::Get</span><span class="params">(<span class="type">char</span> *oufBuff, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> l;  <span class="comment">// 从in到缓冲区末尾的长度</span></span><br><span class="line"></span><br><span class="line">    len = <span class="built_in">min</span>(len, in - out);  <span class="comment">// 可读的数据</span></span><br><span class="line">    <span class="comment">// 先读取从out到buffer末尾的部分</span></span><br><span class="line">    l = <span class="built_in">min</span>(len, size - (out &amp; (size - <span class="number">1</span>)));</span><br><span class="line">    <span class="built_in">Memcpy</span>(oufBuff, buffer + (out &amp; (size - <span class="number">1</span>)), l);</span><br><span class="line">    <span class="comment">// 然后继续读取位于buffer头部的部分</span></span><br><span class="line">    <span class="built_in">Memcpy</span>(oufBuff + l, buffer, len - l);</span><br><span class="line">    out += len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (in == out) &#123; in = <span class="number">0</span>; out = <span class="number">0</span>; &#125;  <span class="comment">// 二者相等时buffer为空，所以置0</span></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后编写测试函数。写者每次向缓冲区写入随机长度的字符，读者则每次从缓冲区读取随机长度的字符并打印。仅同时存在一个读者和一个写者。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">KFifo* kFifo = <span class="keyword">new</span> <span class="built_in">KFifo</span>(<span class="string">&quot;KFifo Test&quot;</span>, <span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BuffWriter</span><span class="params">(<span class="type">int</span> which)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">while</span> (num--) &#123;</span><br><span class="line">        <span class="type">char</span> * inBuff = <span class="string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>;</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">Random</span>() % <span class="number">26</span>;</span><br><span class="line">        <span class="type">int</span> r = kFifo-&gt;<span class="built_in">Put</span>(inBuff, len);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread %s try to put %d chars in kFifo, finally %d in\n&quot;</span>, currentThread-&gt;<span class="built_in">getName</span>(), len, r);</span><br><span class="line">        currentThread-&gt;<span class="built_in">Yield</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BuffReader</span><span class="params">(<span class="type">int</span> which)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">while</span> (num--) &#123;</span><br><span class="line">        <span class="type">char</span> outBuff[<span class="number">256</span>];</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">Random</span>() % <span class="number">26</span>;</span><br><span class="line">        <span class="type">int</span> r = kFifo-&gt;<span class="built_in">Get</span>(outBuff, len);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread %s try to get %d chars from kFifo, finally %d out\n&quot;</span>, currentThread-&gt;<span class="built_in">getName</span>(), len, r);</span><br><span class="line">        outBuff[r] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Read Info =&gt; %s  ==  now buffer unread size %d\n&quot;</span>, outBuff, kFifo-&gt;<span class="built_in">BufferUsedSize</span>());</span><br><span class="line">        currentThread-&gt;<span class="built_in">Yield</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">ThreadTest9</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DEBUG</span>(<span class="string">&#x27;t&#x27;</span>, <span class="string">&quot;Entering ThreadTest5\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Thread* read = <span class="keyword">new</span> <span class="built_in">Thread</span>(<span class="string">&quot;Read&quot;</span>);</span><br><span class="line">    Thread* write = <span class="keyword">new</span> <span class="built_in">Thread</span>(<span class="string">&quot;Write&quot;</span>);</span><br><span class="line"></span><br><span class="line">    write-&gt;<span class="built_in">Fork</span>(BuffWriter, (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line">    read-&gt;<span class="built_in">Fork</span>(BuffReader, (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果如下。</p>
<figure class="highlight shell"><figcaption><span>Shell执行结果</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">root@b5500d28dd66:/nachos/nachos-3.4/code/threads# ./nachos -q 9</span><br><span class="line">Thread Write try to put 13 chars in kFifo, finally 13 in</span><br><span class="line">Thread Read try to get 22 chars from kFifo, finally 13 out</span><br><span class="line">Read Info =&gt; abcdefghijklm  ==  now buffer unread size 0</span><br><span class="line">Thread Read try to get 11 chars from kFifo, finally 0 out</span><br><span class="line">Read Info =&gt;   ==  now buffer unread size 0</span><br><span class="line">Thread Write try to put 17 chars in kFifo, finally 17 in</span><br><span class="line">Thread Read try to get 1 chars from kFifo, finally 1 out</span><br><span class="line">Read Info =&gt; a  ==  now buffer unread size 16</span><br><span class="line">Thread Write try to put 1 chars in kFifo, finally 1 in</span><br><span class="line">Thread Read try to get 12 chars from kFifo, finally 12 out</span><br><span class="line">Read Info =&gt; bcdefghijklm  ==  now buffer unread size 5</span><br><span class="line">Thread Write try to put 16 chars in kFifo, finally 16 in</span><br><span class="line">Thread Read try to get 1 chars from kFifo, finally 1 out</span><br><span class="line">Read Info =&gt; n  ==  now buffer unread size 20</span><br><span class="line">Thread Write try to put 7 chars in kFifo, finally 7 in</span><br><span class="line">No threads ready or runnable, and no pending interrupts.</span><br><span class="line">Assuming the program completed.</span><br><span class="line">Machine halting!</span><br><span class="line"></span><br><span class="line">Ticks: total 180, idle 10, system 170, user 0</span><br><span class="line">Disk I/O: reads 0, writes 0</span><br><span class="line">Console I/O: reads 0, writes 0</span><br><span class="line">Paging: faults 0</span><br><span class="line">Network I/O: packets received 0, sent 0</span><br><span class="line"></span><br><span class="line">Cleaning up...</span><br></pre></td></tr></table></figure>



<h2 id="遇到的困难以及解决方法"><a href="#遇到的困难以及解决方法" class="headerlink" title="遇到的困难以及解决方法"></a>遇到的困难以及解决方法</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] 荒野之萍. Nachos-Lab3-同步与互斥机制模块实现[EB&#x2F;OL]. <a target="_blank" rel="noopener" href="https://icoty.github.io/2019/05/14/nachos-3-4-Lab3/">https://icoty.github.io/2019/05/14/nachos-3-4-Lab3/</a></p>
<p>[2] Github. Nachos中文教程.pdf[EB&#x2F;OL]. <a target="_blank" rel="noopener" href="https://github.com/zhanglizeyi/CSE120/blob/master/Nachos%E4%B8%AD%E6%96%87%E6%95%99%E7%A8%8B.pdf">https://github.com/zhanglizeyi/CSE120/blob/master/Nachos%E4%B8%AD%E6%96%87%E6%95%99%E7%A8%8B.pdf</a></p>
<p>[3] 维基百科. 读写锁[EB&#x2F;OL]. <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%AF%BB%E5%86%99%E9%94%81">https://zh.wikipedia.org/wiki/%E8%AF%BB%E5%86%99%E9%94%81</a></p>
<p>[4] 博客园. 一步一步实现读写锁[EB&#x2F;OL]. <a target="_blank" rel="noopener" href="https://www.cnblogs.com/myd620/p/6129112.html">https://www.cnblogs.com/myd620/p/6129112.html</a></p>
<p>[5] 知乎. 深入理解 Linux 的 RCU 机制[EB&#x2F;OL]. <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/30583695">https://zhuanlan.zhihu.com/p/30583695</a></p>
<p>[6] 博客园. Linux 下的同步机制[EB&#x2F;OL]. <a target="_blank" rel="noopener" href="https://www.cnblogs.com/ck1020/p/6532985.html">https://www.cnblogs.com/ck1020/p/6532985.html</a></p>
<p>[7] CSDN. Linux各种同步机制的比较[EB&#x2F;OL]. <a target="_blank" rel="noopener" href="https://blog.csdn.net/q921374795/article/details/88814272?utm_medium=distribute.pc_relevant.none-task-blog-baidulandingword-3&spm=1001.2101.3001.4242">https://blog.csdn.net/q921374795/article/details/88814272?utm_medium=distribute.pc_relevant.none-task-blog-baidulandingword-3&amp;spm=1001.2101.3001.4242</a></p>
<p>[8] CSDN. linux内核同步机制中的概念介绍和方法[EB&#x2F;OL]. <a target="_blank" rel="noopener" href="https://blog.csdn.net/wealoong/article/details/7957385?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control">https://blog.csdn.net/wealoong/article/details/7957385?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control</a></p>
<p>[9] CSDN. 神奇的大内核锁[EB&#x2F;OL]. <a target="_blank" rel="noopener" href="https://blog.csdn.net/DLUTBruceZhang/article/details/11037159">https://blog.csdn.net/DLUTBruceZhang/article/details/11037159</a></p>
<p>[10] 博客园. linux内核数据结构之kfifo[EB&#x2F;OL]. <a target="_blank" rel="noopener" href="https://www.cnblogs.com/anker/p/3481373.html">https://www.cnblogs.com/anker/p/3481373.html</a></p>
</div><div class="article-licensing box"><div class="licensing-title"><p>Nachos Lab03 同步机制</p><p><a href="https://rlyown.github.io/2020/11/22/Nachos-Lab03-同步机制/">https://rlyown.github.io/2020/11/22/Nachos-Lab03-同步机制/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>Chaos Chen</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2020-11-22</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2023-06-30</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Nachos/">Nachos</a><a class="link-muted mr-2" rel="tag" href="/tags/Synchronization/">Synchronization</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/11/24/Vmware-Fusion-TPM%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Vmware Fusion TPM安装过程</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/11/17/Nachos-Lab02-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"><span class="level-item">Nachos Lab02 虚拟内存</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comentarios</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "9570731da32f9903e10f738cb2c2be69",
            repo: "rlyown.github.io",
            owner: "Rlyown",
            clientID: "0dc9a246a80c473e7d31",
            clientSecret: "08612f9152910db6288e61191a4221bad6aea8e5",
            admin: ["Rlyown"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 20,
            pagerDirection: "last",
            
            
            enableHotKey: true,
            language: "zh-CN",
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catálogo</h3><ul class="menu-list"><li><a class="level is-mobile" href="#第一部分"><span class="level-left"><span class="level-item">1</span><span class="level-item">第一部分</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Exercise1-调研"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">Exercise1 调研</span></span></a></li><li><a class="level is-mobile" href="#Exercise2-源代码阅读"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">Exercise2 源代码阅读</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#关于线程阻塞后中断的问题"><span class="level-left"><span class="level-item">1.2.1</span><span class="level-item">关于线程阻塞后中断的问题</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Exercise3-实现锁和条件变量"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">Exercise3 实现锁和条件变量</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#思路"><span class="level-left"><span class="level-item">1.3.1</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#实现"><span class="level-left"><span class="level-item">1.3.2</span><span class="level-item">实现</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Exercise4-实现同步互斥实例"><span class="level-left"><span class="level-item">1.4</span><span class="level-item">Exercise4 实现同步互斥实例</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#生产者-消费者问题（信号量实现）"><span class="level-left"><span class="level-item">1.4.1</span><span class="level-item">生产者-消费者问题（信号量实现）</span></span></a></li><li><a class="level is-mobile" href="#生产者-消费者问题（条件变量实现）"><span class="level-left"><span class="level-item">1.4.2</span><span class="level-item">生产者-消费者问题（条件变量实现）</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Challenge-1-实现barrier"><span class="level-left"><span class="level-item">1.5</span><span class="level-item">Challenge 1  实现barrier</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#思路-1"><span class="level-left"><span class="level-item">1.5.1</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#实现-1"><span class="level-left"><span class="level-item">1.5.2</span><span class="level-item">实现</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Challenge-2-实现read-x2F-write-lock"><span class="level-left"><span class="level-item">1.6</span><span class="level-item">Challenge 2 实现read/write lock</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#思路-2"><span class="level-left"><span class="level-item">1.6.1</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#实现-2"><span class="level-left"><span class="level-item">1.6.2</span><span class="level-item">实现</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Challenge-3-研究Linux的kfifo机制是否可以移植到Nachos上作为一个新的同步模块"><span class="level-left"><span class="level-item">1.7</span><span class="level-item">Challenge 3  研究Linux的kfifo机制是否可以移植到Nachos上作为一个新的同步模块</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#思路-3"><span class="level-left"><span class="level-item">1.7.1</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#实现-3"><span class="level-left"><span class="level-item">1.7.2</span><span class="level-item">实现</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#遇到的困难以及解决方法"><span class="level-left"><span class="level-item">2</span><span class="level-item">遇到的困难以及解决方法</span></span></a></li><li><a class="level is-mobile" href="#参考文献"><span class="level-left"><span class="level-item">3</span><span class="level-item">参考文献</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/f7.png" alt="Real Own" height="28"></a><p class="is-size-7"><span>&copy; 2023 Chaos Chen</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visitado por <span id="busuanzi_value_site_uv">0</span> usuarios</span></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-hans");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Volver arriba" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "Este sitio web utiliza cookies para mejorar su experiencia.",
          dismiss: "¡Entendido!",
          allow: "Permitir cookies",
          deny: "Descenso",
          link: "Aprende más",
          policy: "Política de cookies",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Teclea algo..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Teclea algo...","untitled":"(Sin título)","posts":"Entradas","pages":"Páginas","categories":"Categorías","tags":"Etiquetas"});
        });</script></body></html>