<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Nachos Lab01 线程机制 - Real Own</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Chaos Chen"><meta name="msapplication-TileImage" content="/img/f7.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Chaos Chen"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="这次实习希望通过理解nachos中对于线程Thread，调度器scheduler，时间片Timer以及相关文件的代码，从而能够扩展线程的结构，实现全局线程管理，线程调度等方法。最终理解什么是线程，线程是如何被调度的，以及时间片在其中是如何发挥作用的。"><meta property="og:type" content="blog"><meta property="og:title" content="Nachos Lab01 线程机制"><meta property="og:url" content="https://rlyown.github.io/2020/11/16/Nachos-Lab01-%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6/"><meta property="og:site_name" content="Real Own"><meta property="og:description" content="这次实习希望通过理解nachos中对于线程Thread，调度器scheduler，时间片Timer以及相关文件的代码，从而能够扩展线程的结构，实现全局线程管理，线程调度等方法。最终理解什么是线程，线程是如何被调度的，以及时间片在其中是如何发挥作用的。"><meta property="og:image" content="https://rlyown.github.io/2020/11/16/Nachos-Lab01-%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6/task_struct.png"><meta property="og:image" content="https://rlyown.github.io/2020/11/16/Nachos-Lab01-%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6/exercise2_result.png"><meta property="og:image" content="https://rlyown.github.io/2020/11/16/Nachos-Lab01-%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6/exercise5_result.png"><meta property="og:image" content="https://rlyown.github.io/2020/11/16/Nachos-Lab01-%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6/challenge_result.png"><meta property="article:published_time" content="2020-11-16T11:12:12.000Z"><meta property="article:modified_time" content="2023-06-30T08:53:26.323Z"><meta property="article:author" content="Chaos Chen"><meta property="article:tag" content="Nachos"><meta property="article:tag" content="Context of Execution"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://rlyown.github.io/2020/11/16/Nachos-Lab01-%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6/task_struct.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://rlyown.github.io/2020/11/16/Nachos-Lab01-%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6/"},"headline":"Nachos Lab01 线程机制","image":["https://rlyown.github.io/2020/11/16/Nachos-Lab01-%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6/task_struct.png","https://rlyown.github.io/2020/11/16/Nachos-Lab01-%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6/exercise2_result.png","https://rlyown.github.io/2020/11/16/Nachos-Lab01-%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6/exercise5_result.png","https://rlyown.github.io/2020/11/16/Nachos-Lab01-%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6/challenge_result.png"],"datePublished":"2020-11-16T11:12:12.000Z","dateModified":"2023-06-30T08:53:26.323Z","author":{"@type":"Person","name":"Chaos Chen"},"publisher":{"@type":"Organization","name":"Real Own","logo":{"@type":"ImageObject","url":"https://rlyown.github.io/img/f7.png"}},"description":"这次实习希望通过理解nachos中对于线程Thread，调度器scheduler，时间片Timer以及相关文件的代码，从而能够扩展线程的结构，实现全局线程管理，线程调度等方法。最终理解什么是线程，线程是如何被调度的，以及时间片在其中是如何发挥作用的。"}</script><link rel="canonical" href="https://rlyown.github.io/2020/11/16/Nachos-Lab01-%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6/"><link rel="alternate" href="/atom.xml" title="Real Own" type="application/atom+xml"><link rel="icon" href="/img/f7.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Oxanium:wght@300;400;600&amp;family=Roboto+Mono"><link rel="stylesheet" href="/css/cyberpunk.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/f7.png" alt="Real Own" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/Rlyown/rlyown.github.io"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catálogo" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Buscar" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Publicado hace&nbsp;<time dateTime="2020-11-16T11:12:12.000Z" title="11/16/2020, 7:12:12 PM">2020-11-16</time></span><span class="level-item">Actualizado hace&nbsp;<time dateTime="2023-06-30T08:53:26.323Z" title="6/30/2023, 4:53:26 PM">2023-06-30</time></span><span class="level-item"><a class="link-muted" href="/categories/Operating-System/">Operating System</a></span><span class="level-item">43 minutes de lectura (Aproximadamente 6388 palabras)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>&nbsp;visitas</span></div></div><h1 class="title is-3 is-size-4-mobile">Nachos Lab01 线程机制</h1><div class="content"><h2 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h2><h3 id="调研"><a href="#调研" class="headerlink" title="调研"></a>调研</h3><blockquote>
<p>调研Linux或Windows中进程控制块（PCB）的基本实现方式，理解与Nachos的异同。调研Linux或Windows中采用的进程&#x2F;线程调度算法。</p>
</blockquote>
<p>Linux版本2.6.11：Linux使用轻量级进程，进程间允许共享资源。实现多线程应用的简单方式就是把轻量级进程与每个线程关联起来，线程间就可以通过共享资源的方式来访问相同的应用数据结构集。在Linux中，使用<em>task_struct</em>结构来存储与一个进程相关的所有信息。其基本结构如下图。其中Linux的进程状态有：可运行状态(<em>TASK_RUNNING</em>)，可中断的等待状态(<em>TASK_INTERRUPTIBLE</em>)，不可中断的等待状态(<em>TASK_UNINTERRUPTIBLE</em>)，暂停状态(<em>TASK_STOPPED</em>)，跟踪状态(<em>TASK_TRACED</em>)，僵死状态(<em>EXIT_ZOMBIE</em>)，僵死撤销状态(<em>EXIT_DEAD</em>)。</p>
<p>在Nachos中也同样使用Thread类来定义线程所需的信息和方法。但是Nachos的实现是基于线程的，要求至少存在一个主线程。而对于主线程则可以使用fork方法来创建子线程来执行任务。</p>
<p>Linux的进程调度，将进程分为不同的类型进行调度。<em>SCHED_FIFO</em>先进先出的实时进程，只要没有可运行的更高优先级实时进程，就可以一直运行。<em>SCHED_RR</em>时间片轮转的实时进程，保证具有相同优先级的<em>SCHED_RR</em>实时进程可以公平地分配CPU时间。<em>SCHED_NORMAL</em>，普通的分时进程，普通进程会同时维护静态优先级（用于评估该进程与其他普通进程之间调度的程度）和动态优先级（用于调度程序选择新进程）。</p>
<p>Linux对于普通进程，调度器会维持两个不相交的可运行进程集合，活动进程和过期进程，用于保证获得较多时间片的高静态优先级进程不会影响静态优先级较低的进程执行。而实时进程则在执行过程中会尽可能多的运行，即禁止优先级低的进程执行。只有在发生诸如高优先级的实时进程抢占、IO阻塞、进程结束、主动放弃CPU、基于时间片轮转且用完了时间片等事件时，才会发生实时进程被另一个进程取代。</p>
<img src="/2020/11/16/Nachos-Lab01-%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6/task_struct.png" class="" title="task_struct">

<h2 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h2><p>由于写下此博文时，Nachos已经在做后续的实习了，改动较多，导致曾经的测试函数得不到相同的测试结果了。因此所有的测试结果截图均来自当时的实验报告。</p>
<h3 id="Exercise1-源代码阅读"><a href="#Exercise1-源代码阅读" class="headerlink" title="Exercise1 源代码阅读"></a>Exercise1 源代码阅读</h3><blockquote>
<p>仔细阅读下列源代码，理解Nachos现有的线程机制。</p>
<ul>
<li><p>code&#x2F;threads&#x2F;main.cc和code&#x2F;threads&#x2F;threadtest.cc</p>
</li>
<li><p>code&#x2F;threads&#x2F;thread.h和code&#x2F;threads&#x2F;thread.cc</p>
</li>
</ul>
</blockquote>
<p><em>code&#x2F;threads&#x2F;main.cc</em>：定义了NachOS的入口，可以通过传入不同的参数，直接调用NachOS上不同部分的功能函数。可以用于调试和测试。</p>
<p> <em>code&#x2F;threads&#x2F;threadtest.cc</em>：该文件给出了一个简易的线程测试样例，两个线程0和1，轮流主动让出CPU。后续对Thread的修改，可以在此处设置编写相应的测试函数来进行验证。</p>
<p><em>code&#x2F;threads&#x2F;thread.h</em>：主要定义了Thread所相关的线程管理函数，以及一些与线程上下文环境有关的变量。需要重点提及的是Thread类头两个变量（即栈顶指针和机器状态寄存器）不能修改顺序是因为NachOS在进行线程切换（调用SWITCH函数）时，会按照这个顺序依次找到线程入口，然后设置线程上下文寄存器。</p>
<p><em>code&#x2F;threads&#x2F;thread.cc</em>：这里面比较重要的函数如下：</p>
<ul>
<li>Fork：Fork用于创建一个新的线程，而在这个创建过程中比较重要的函数就是StackAllocate。StackAllocate函数仅在Fork中被调用，它会根据宏定义的栈大小创建一个栈，然后在栈顶放入ThreadRoot函数（由ThreadRoot入口可以转而运行线程所需要运行的任务函数），并且设置一些机器状态寄存器。<strong>需要特别说明的就是，新线程是由ThreadRoot转而运行任务，而不是直接从任务函数开始</strong>。</li>
</ul>
<ul>
<li>Yield和Sleep函数：二者在功能上十分地相近，都是主动让出CPU，调度下一个线程。其中最大的差别就是Sleep在就绪队列为空时，会调用中断中的Idle函数，然后一直等待新的线程进行调度；而Yield函数在就绪队列为空时，会直接返回。</li>
</ul>
<h3 id="Exercise2-扩展线程的数据结构"><a href="#Exercise2-扩展线程的数据结构" class="headerlink" title="Exercise2 扩展线程的数据结构"></a>Exercise2 扩展线程的数据结构</h3><blockquote>
<p>增加“用户ID、线程ID”两个数据成员，并在Nachos现有的线程管理机制中增加对这两个数据成员的维护机制。</p>
</blockquote>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>由于Nachos中并没有实现多用户相关的机制，所以需要人为地维护用户信息。考虑到便捷性，直接在Thread类中增加相关的机制。</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>在<em>threads&#x2F;thread.h</em>文件内的Thread类中，新增私有成员用户ID（uid）和线程ID（tid），并分别设置了获取这些成员信息的<em>get</em>函数，以及uid的<em>set</em>函数。</p>
<p>线程内的用户ID（uid）设置<em>set</em>函数是考虑到Nachos没有现成的多用户管理机制，增加一个全局的用户管理机制过于麻烦。为了简便，通过显式地调用<em>setUid</em>的方式来进程用户管理。而线程ID（tid）没有<em>setTid</em>也是因为后续实现了全局线程的管理机制。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 改动位于threads/thread.h内的Thread类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> uid;</span><br><span class="line">    <span class="type">int</span> tid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setUid</span><span class="params">(<span class="type">int</span> new_uid)</span> </span>&#123;</span><br><span class="line">        uid = new_uid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getUid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> uid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getTid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tid;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>当然，uid和tid和值均需要初始化。uid在Thread的构造函数（位于<em>threads&#x2F;thread.cc</em>）中初始化为任意值即可。而tid的初始值来源于全局线程管理机制的分配。</p>
<h3 id="Exercise3-增加全局线程管理机制"><a href="#Exercise3-增加全局线程管理机制" class="headerlink" title="Exercise3  增加全局线程管理机制"></a>Exercise3  增加全局线程管理机制</h3><blockquote>
<p>在Nachos中增加对线程数量的限制，使得Nachos中最多能够同时存在128个线程； </p>
<p>仿照Linux中PS命令，增加一个功能TS(Threads Status)，能够显示当前系统中所有线程的信息和状态。</p>
</blockquote>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>在Nachos中，有两个文件*threads&#x2F;system.h(cc)*，它们负责管理Nachos中的一些全局变量以及一些初始化的工作，因此可以在此处添加相应全局线程管理机制。因为要求线程数的上限为128，所以可以设置一个长度为128的数组，用于记录tid的分配情况，而数组的大小也限制能够被分配出去的tid的数量。</p>
<p>要实现TS功能，光有tid的管理数组还不够，还需要一个能够根据tid获取相应线程信息的功能。这里可以设置一个与之前的数组等大的平行数组，用于记录每个<em>tid</em>所对应的线程指针。</p>
<p>总之上述的实现方式可以是：</p>
<ol>
<li>设置两个数组，一个用于记录tid的分配情况，另一个用于记录tid所对应的线程指针</li>
<li>上述二者可以合并成一个组数，该数组存储线程指针，根据值是否为<code>NULL</code>来判断该tid是否已被分配。</li>
<li>用结构体来存储tid和线程指针</li>
</ol>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>这里采取上述方法二。</p>
<p>在<em>threads&#x2F;system.h</em>文件中添加如下的全局变量，分别是全局线程数量的宏<code>NOTHREAD</code>，指向线程的指针数组（该数组存储各个线程的地址，其地址对应的下标即为线程的<em>tid</em>），以及用于查看所有线程状态的函数<em>ThreadsStatus</em>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 改动位于threads/system.h</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 最大线程数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NOTHREAD 128</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> Thread* thread_point[NOTHREAD];</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">ThreadsStatus</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>然后在<em>threads&#x2F;system.cc</em>文件中将thread_point的数组元素初始化为0（也可以使用NULL替代），这个步骤是为了保证其存储的所有指针为0（0表示未分配），否则系统会误认为该地址已分配给某个进程而导致的误操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 改动位于threads/system.cc中的Initialize函数</span></span><br><span class="line"><span class="comment"> * 该函数用于Nachos中的全局数据初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NOTHREAD; i++) &#123;</span><br><span class="line">    thread_point[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相应的在<em>threads&#x2F;thread.cc</em>文件下的Thread构造函数中添加了tid的分配方式，在线程创建的时候，从全局线程指针数组中获取一个tid，并在其中放入该线程的地址。与之相对应的，在析构函数中将tid所对应的指针设为0。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 改动位于threads/thread.cc中的Thread构造函数Thread::Thread</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">this</span>-&gt;uid = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 获取tid</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NOTHREAD; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (thread_point[i] == <span class="number">0</span>) &#123;</span><br><span class="line">        tid = i;</span><br><span class="line">        thread_point[i] = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 改动位于threads/thread.cc中的Thread析构函数Thread::~Thread</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">thread_point[tid] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>最后获取所有线程状态的函数<em>ThreadsStatus</em>实现在<em>system.cc</em>文件中，该函数的主要功能就是遍历线程指针数组，并打印所有线程的uid，tid，name，以及status。因此，也在<em>thread.h</em>文件中，对Thread类新增了一个成员函数<em>getStatus</em>用于获取线程状态信息。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 改动位于threads/system.cc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadsStatus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> tid = <span class="number">0</span>; tid &lt; NOTHREAD; tid++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (thread_point[tid] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果tid已经分发</span></span><br><span class="line">            Thread * thd = thread_point[tid];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取线程状态的字符串，方便打印</span></span><br><span class="line">            <span class="type">char</span> * status;</span><br><span class="line">            <span class="keyword">switch</span> (thd-&gt;<span class="built_in">getStatus</span>()) &#123;</span><br><span class="line">                <span class="keyword">case</span> JUST_CREATED:</span><br><span class="line">                    status = <span class="string">&quot;JUST_CREATED&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> RUNNING:</span><br><span class="line">                    status = <span class="string">&quot;RUNNING&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> READY:</span><br><span class="line">                    status = <span class="string">&quot;READY&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> BLOCKED:</span><br><span class="line">                    status = <span class="string">&quot;BLOCKED&quot;</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;uid: %d  tid: %d  name: %s  status: %s\n&quot;</span>, thd-&gt;<span class="built_in">getUid</span>(), thd-&gt;<span class="built_in">getTid</span>(), thd-&gt;<span class="built_in">getName</span>(), status);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后测试函数如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 改动位于threads/threadtest.cc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_nothing</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (i % <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: &#123;</span><br><span class="line">            <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">            <span class="type">int</span> tmp_count = <span class="number">100</span>;</span><br><span class="line">            <span class="keyword">while</span> (tmp_count--);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line">            <span class="type">int</span> tmp_count_2 = <span class="number">1000</span>;</span><br><span class="line">            <span class="keyword">while</span> (tmp_count_2--);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadTest2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DEBUG</span>(<span class="string">&#x27;t&#x27;</span>, <span class="string">&quot;Entering ThreadTest2\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Thread * ThreadBox[<span class="number">10</span>];</span><br><span class="line">  	<span class="comment">// 构造线程名</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">10</span>] = <span class="string">&quot;Thread_a\0&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="type">char</span> *new_name = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">7</span>) &#123;</span><br><span class="line">                new_name[j] = name[j] + i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                new_name[j] = name[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ThreadBox[i] = <span class="keyword">new</span> <span class="built_in">Thread</span>(new_name);</span><br><span class="line">        ThreadBox[i]-&gt;<span class="built_in">setUid</span>(i + <span class="number">10</span>);</span><br><span class="line">        ThreadBox[i]-&gt;<span class="built_in">Fork</span>(do_nothing, (<span class="type">void</span> *)i);</span><br><span class="line"></span><br><span class="line">      	<span class="comment">// 为了效果手动修改了一些状态</span></span><br><span class="line">        ThreadBox[i]-&gt;<span class="built_in">setStatus</span>((READY + i) % <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ThreadsStatus</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<img src="/2020/11/16/Nachos-Lab01-%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6/exercise2_result.png" class="" title="Exercise2 Result">



<h3 id="Exercise4-源代码阅读"><a href="#Exercise4-源代码阅读" class="headerlink" title="Exercise4 源代码阅读"></a>Exercise4 源代码阅读</h3><blockquote>
<p>仔细阅读下列源代码，理解Nachos现有的线程调度算法。</p>
<ul>
<li><p>code&#x2F;threads&#x2F;scheduler.h和code&#x2F;threads&#x2F;scheduler.cc</p>
</li>
<li><p>code&#x2F;threads&#x2F;switch.s</p>
</li>
<li><p>code&#x2F;machine&#x2F;timer.h和code&#x2F;machine&#x2F;timer.cc</p>
</li>
</ul>
</blockquote>
<p><em>code&#x2F;threads&#x2F;scheduler.h</em>和<em>scheduler.cc</em>：主要是声明和实现了关于调度器的数据结构及相关方法。<em>ReadyToRun</em>方法，用于将新的线程加入到就绪队列；<em>FindNextToRun</em>则是根据规则从就绪队列中取出一个线程指针；<em>Run</em>方法则是真正负责线程调度，将当前运行的线程换出CPU，将下一个线程换入CPU。</p>
<p><em>code&#x2F;threads&#x2F;switch.s</em>：该文件即是<em>SWITCH</em>函数的真正实现。主要负责保存待换出线程的相关寄存器的值，然后将待换入线程的上下文信息放入寄存器当中。</p>
<p><em>code&#x2F;machine&#x2F;timer.h和timer.cc</em>：主要提供了时间片所需的相关方法。其中最重要的函数就是<em>TimerExpired</em>。Timer类实现了每隔一定时间（时间片的长度从<em>TimeOfNextInterrupt</em>获取）向interrupt发送一个中断，该中断的处理函数中调用了<em>TimerExpired</em>。表明当一个时间片结束的时候，<em>TimerExpired</em>函数被调用从而导致执行<em>TimerInterruptHandler</em>函数（位于<em>threads&#x2F;system.cc</em>）。而<em>TimerInterruptHandler</em>会间接引发线程的上下文切换，从而实现了时间片的轮转。</p>
<h3 id="Exercise5-线程调度算法扩展"><a href="#Exercise5-线程调度算法扩展" class="headerlink" title="Exercise5 线程调度算法扩展"></a>Exercise5 线程调度算法扩展</h3><blockquote>
<p>扩展线程调度算法，实现基于优先级的抢占式调度算法</p>
</blockquote>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>基于优先级的调度，首先要为每个线程设置一个优先级变量，并增设相应的维护函数。然后修改线程调度器Scheduler相应方法的实现，使得优先级最高的线程能够被最先调度。</p>
<p>然后是关于抢占的实现。仔细观察时钟类Timer的实现，可以发现该类会周期地向中断调度器发送时钟中断。初始化时执行一次下述代码，会让中断执行<em>TimerExpired</em>方法，然后<em>TimerExpired</em>方法又会执行下述代码，从而实现每隔一个时间片就会发生一次时钟中断。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * machine/timer.cc中Timer的构造函数和TimerExpired出现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">interrupt-&gt;<span class="built_in">Schedule</span>(TimerHandler, (<span class="type">int</span>) <span class="keyword">this</span>, <span class="built_in">TimeOfNextInterrupt</span>(), </span><br><span class="line">TimerInt);</span><br></pre></td></tr></table></figure>

<ul>
<li><p><em>TimerHandler</em>是为了处理类方法无法作为函数指针传入，所以增设的协助函数。该函数主要用途就是调用<em>TimerExpired</em>方法，即让中断调度器能够调用<em>TimerExpired</em>方法。</p>
</li>
<li><p><em>TimeOfNextInterrupt</em>则是获取两次中断的时间间隔，即时间片。Nachos允许随机时间片。</p>
</li>
<li><p><em>TimerInt</em>表示中断的类型是一个时钟中断</p>
</li>
</ul>
<p>而时钟中断的处理函数<em>TimerInterruptHandler</em>位于<em>threads&#x2F;system.cc</em>。该函数会调用<code>interrupt-&gt;YieldOnReturn();</code>方法，该方法会设置中断interrupt的yieldOnReturn属性为<code>TRUE</code>是为了避免直接调用<em>Yield</em>函数导致中断处理线程被换出CPU。</p>
<p>如果搜索yieldOnReturn被调用的位置可以发现，在<em>machine&#x2F;interrupt.cc</em>的<em>OneTick</em>函数中会看到如下代码。<strong>可以得知在时钟中断发生时，会引发线程的切换</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">if</span> (yieldOnReturn) &#123;    <span class="comment">// if the timer device handler asked </span></span><br><span class="line">            <span class="comment">// for a context switch, ok to do it now</span></span><br><span class="line">yieldOnReturn = FALSE;</span><br><span class="line">   status = SystemMode;      <span class="comment">// yield is a kernel routine</span></span><br><span class="line">currentThread-&gt;<span class="built_in">Yield</span>();</span><br><span class="line">status = old;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这里有两个需要关注的点就是：</p>
<ol>
<li><p><strong>OneTick在什么时候会被执行</strong></p>
<p>A：查看Interrupt类的<em>SetLevel</em>函数（开中断函数），可以得知，关中断再开中断会执行<em>OneTick</em>函数。也就是说在中断恢复的时候执行。同时检索可以得知，在<em>Machine::Run()<em>中，执行完一次用户指令也会执行</em>OneTick</em>函数。</p>
</li>
<li><p><strong>中断处理程序在什么时候会被执行</strong></p>
<p>A：查看<em>OneTick</em>的注释和代码可以得知有一个<em>CheckIfDue</em>方法，在处理中断调度器。如果出现了一个中断，则调用它的中断处理程序<code>(*(toOccur-&gt;handler))(toOccur-&gt;arg);</code>。所以中断处理程序是在<em>OneTick</em>中被调用执行的。</p>
</li>
</ol>
<p>这样时间中断的流程就很清晰了：由硬件模拟例程调用<em>Interrupt::Schedule</em>发送时钟中断；然后在执行完用户指令或者开中断时调用OneTick函数前进一个时间单位（用户态前进一个用户事件，系统态则前进一个系统时间）；再然后由<em>CheckIfDue</em>检查中断是否要发生；如果要发生时钟中断，则引发时钟中断处理函数<em>TimerInterruptHandler</em>的执行，处理结束后引发线程的切换。</p>
<blockquote>
<p>注：因为在屏蔽中断期间，不应该允许任何中断的发生或者线程的调度，这样才能模拟原子操作。在系统态下，同时一次<em>OneTick</em>函数的执行也为模拟的系统时间增加了<em>10</em>个单位的时间（该值的定义位于<em>machine&#x2F;stats.h</em>）。</p>
</blockquote>
<p>最后为了Nachos能够产生等长的时间片，修改<em>threads&#x2F;system.cc</em>，增加<code>else</code>的部分。因为原先的Nachos仅在随机的时间片上启用时钟。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * threads/system.cc中的Initialize</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (randomYield)          <span class="comment">// start the timer (if needed)</span></span><br><span class="line">timer = <span class="keyword">new</span> <span class="built_in">Timer</span>(TimerInterruptHandler, <span class="number">0</span>, randomYield);</span><br><span class="line">   <span class="keyword">else</span>  <span class="comment">// 增加的部分</span></span><br><span class="line">       timer = <span class="keyword">new</span> <span class="built_in">Timer</span>(TimerInterruptHandler, <span class="number">0</span>, randomYield);</span><br></pre></td></tr></table></figure>



<h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><p>修改<em>threads&#x2F;thread.h</em>文件中的Thread类，为其添加代表优先级的私有成员priority以及相关的管理函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 改动位于threads/thread.h中的Thread类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 优先级</span></span><br><span class="line">    <span class="type">int</span> priority;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getPriority</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> priority;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setPriority</span><span class="params">(<span class="type">int</span> pri)</span> </span>&#123;</span><br><span class="line">        priority = pri;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>然后修改<em>threads&#x2F;scheduler.cc</em>中的<em>ReadyToRun</em>函数，<em>ReadyToRun</em>仅负责将线程插入到就绪队列而不考虑调度线程到CPU上。因为是基于优先级的调度，所以原本的将新线程加入就绪队列尾部的做法不能满足需求。将其修改为如下方式，使用有序插入，且排序的依据key是线程的优先级。由于<em>SortedInsert</em>函数是增序排列，key值最小的元素会排在列表的首部，同时在<em>FindNextToRun</em>方法中remove返回的是队列的首部元素，因此导致了priority值越小越会被优先调度，即priority越小优先级越高。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 改动位于threads/scheduler.cc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">Scheduler::ReadyToRun</span> <span class="params">(Thread *thread)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">DEBUG</span>(<span class="string">&#x27;t&#x27;</span>, <span class="string">&quot;Putting thread %s on ready list.\n&quot;</span>, thread-&gt;<span class="built_in">getName</span>());</span><br><span class="line"></span><br><span class="line">    thread-&gt;<span class="built_in">setStatus</span>(READY);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优先级抢占调度</span></span><br><span class="line">    readyList-&gt;<span class="built_in">SortedInsert</span>((<span class="type">void</span> *)thread, thread-&gt;<span class="built_in">getPriority</span>());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>联想到时间片会引发线程上下文切换。因此修改<em>threads&#x2F;thread.cc</em>文件中<em>Yield</em>方法的实现。在线程让出CPU的时候，检查就绪队列顶部线程的优先级，如果该线程的优先级低于当前线程的优先级，则不让出CPU继续运行，从而实现新进程可以在时钟中断时抢占。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 改动位于threads/thread.cc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">Thread::Yield</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Thread *nextThread;</span><br><span class="line">    IntStatus oldLevel = interrupt-&gt;<span class="built_in">SetLevel</span>(IntOff);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">ASSERT</span>(<span class="keyword">this</span> == currentThread);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">DEBUG</span>(<span class="string">&#x27;t&#x27;</span>, <span class="string">&quot;Yielding thread \&quot;%s\&quot;\n&quot;</span>, <span class="built_in">getName</span>());</span><br><span class="line"></span><br><span class="line">    nextThread = scheduler-&gt;<span class="built_in">FindNextToRun</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nextThread != <span class="literal">NULL</span>) &#123;</span><br><span class="line">				<span class="comment">// 优先级抢占调度</span></span><br><span class="line">        <span class="comment">// 规定数字越小优先级越大</span></span><br><span class="line">        <span class="keyword">if</span> (nextThread-&gt;<span class="built_in">getPriority</span>() &gt; priority) &#123;</span><br><span class="line">            <span class="comment">// 如果下一个线程的优先级小于当前线程，则不调度</span></span><br><span class="line">            scheduler-&gt;<span class="built_in">ReadyToRun</span>(nextThread);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            scheduler-&gt;<span class="built_in">ReadyToRun</span>(<span class="keyword">this</span>);</span><br><span class="line">            scheduler-&gt;<span class="built_in">Run</span>(nextThread);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    (<span class="type">void</span>) interrupt-&gt;<span class="built_in">SetLevel</span>(oldLevel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>为简化测试，让每个线程在执行完一次<code>printf</code>之后就尝试主动放弃CPU，从而模拟周期性的新线程抢占CPU。测试函数如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 改动位于threads/threadtest.cc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_priority</span><span class="params">(<span class="type">int</span> tid)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (num = <span class="number">0</span>; num &lt; <span class="number">10</span>; num++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;*** thread %d looped %d times with priority %d\n&quot;</span>, tid, num, currentThread-&gt;<span class="built_in">getPriority</span>());</span><br><span class="line">        currentThread-&gt;<span class="built_in">Yield</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">ThreadTest3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DEBUG</span>(<span class="string">&#x27;t&#x27;</span>, <span class="string">&quot;Entering ThreadTest3\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Thread * threadbox[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        threadbox[i] = <span class="keyword">new</span> <span class="built_in">Thread</span>(<span class="string">&quot;sub_thread&quot;</span>);</span><br><span class="line">        threadbox[i]-&gt;<span class="built_in">setPriority</span>(<span class="number">4</span> - i);</span><br><span class="line">        threadbox[i]-&gt;<span class="built_in">Fork</span>(do_priority, (<span class="type">void</span> *)(threadbox[i]-&gt;<span class="built_in">getTid</span>()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2020/11/16/Nachos-Lab01-%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6/exercise5_result.png" class="" title="Exercise5 Result">


<h3 id="Challenge-线程调度算法扩展"><a href="#Challenge-线程调度算法扩展" class="headerlink" title="Challenge 线程调度算法扩展"></a>Challenge 线程调度算法扩展</h3><p>这里所实现的是非抢占的多级队列反馈算法。</p>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol>
<li>在Thread类中增加属性用于记录时间片的使用情况</li>
<li>修改调度器Scheduler类，将原来的单一队列换成三个就绪队列。队列之间根据时间片的不同，安排不同的优先级。优先级越高的队列，所能使用的时间片越短</li>
<li>修改线程调度的方式。根据线程已经使用的时间片数量，决定线程即将放入的就绪队列。以及按照队列彼此之间的优先级，决定哪个线程会被优先调度。仅当高优先级的就绪队列为空时，才会调度较低优先级队列中的线程。</li>
<li>修改时钟中断处理函数，让线程在耗尽其所在队列允许的时间片之前，不会因为时钟中断而被换出CPU。（由Exercise5的思考部分可知，时钟中断处理函数仅在<code>interrupt-&gt;YieldOnReturn();</code>方法被执行时才会引发线程上下文切换）</li>
</ol>
<h4 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h4><p>首先在<em>threads&#x2F;thread.h</em>文件中，给Thread类添加一个私有成员usedTimeSlices，用于记录该线程已使用的时间片，并为其增设两个公共成员函数<em>getUsedTimeSlices</em>和<em>setUsedTimeSlices</em>，用于获取和设置线程已使用的时间片。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 改动位于threads/thread.h中的Thread类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 已使用的时间片</span></span><br><span class="line">    <span class="type">int</span> usedTimeSlices;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getUsedTimeSlices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> usedTimeSlices;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setUsedTimeSlices</span><span class="params">(<span class="type">int</span> uts)</span> </span>&#123;</span><br><span class="line">        usedTimeSlices = uts;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>然后修改<em>threads&#x2F;scheduler.h</em>文件，为Scheduler类增加如下三个不同的队列。这三个队列相互之间的优先级为$QTimeSlice_2 &gt; QTimeSlice_4 &gt; QTimeSlice_8$。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 改动位于threads/scheduler.h中的Scheduler类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">List *QTimeSlice_2;  <span class="comment">// 时间片为2</span></span><br><span class="line">List *QTimeSlice_4;  <span class="comment">// 时间片为4</span></span><br><span class="line">List *QTimeSlice_8;  <span class="comment">// 时间片为8</span></span><br></pre></td></tr></table></figure>

<p>因此<em>threads&#x2F;scheduler.cc</em>文件中的构造函数和析构函数中，添加为这三个队列分配和回收空间的代码。同时修改<em>ReadyToRun</em>函数，根据线程已使用的时间片长度，决定线程加入到哪个就绪队列。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 改动位于threads/scheduler.cc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Scheduler::<span class="built_in">Scheduler</span>()</span><br><span class="line">&#123;</span><br><span class="line">    QTimeSlice_2 = <span class="keyword">new</span> List;</span><br><span class="line">    QTimeSlice_4 = <span class="keyword">new</span> List;</span><br><span class="line">    QTimeSlice_8 = <span class="keyword">new</span> List;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">Scheduler::~<span class="built_in">Scheduler</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> QTimeSlice_2;</span><br><span class="line">    <span class="keyword">delete</span> QTimeSlice_4;</span><br><span class="line">    <span class="keyword">delete</span> QTimeSlice_8;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">Scheduler::ReadyToRun</span> <span class="params">(Thread *thread)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">DEBUG</span>(<span class="string">&#x27;t&#x27;</span>, <span class="string">&quot;Putting thread %s on ready list.\n&quot;</span>, thread-&gt;<span class="built_in">getName</span>());</span><br><span class="line"></span><br><span class="line">    thread-&gt;<span class="built_in">setStatus</span>(READY);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> usedTimeSlices = thread-&gt;<span class="built_in">getUsedTimeSlices</span>();</span><br><span class="line">    <span class="keyword">if</span> (usedTimeSlices &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        QTimeSlice_2-&gt;<span class="built_in">Append</span>((<span class="type">void</span> *)thread);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (usedTimeSlices &lt; <span class="number">6</span>) &#123;</span><br><span class="line">        QTimeSlice_4-&gt;<span class="built_in">Append</span>((<span class="type">void</span> *)thread);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        QTimeSlice_8-&gt;<span class="built_in">Append</span>((<span class="type">void</span> *)thread);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后修改<em>FindNextToRun</em>函数，根据队列间的优先级选择下一个调度的线程。如果高优先级的队列存在就绪的线程，则会被优先调度。如果较高优先级的队列全部为空，则会调度最低优先级的队列。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 改动位于threads/scheduler.cc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Thread *</span></span><br><span class="line"><span class="function"><span class="title">Scheduler::FindNextToRun</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 队列相互之间是存在优先级的，QTimeSlice_2 &gt; QTimeSlice_4 &gt; QTimeSlice_8</span></span><br><span class="line">    <span class="comment">// 优先查找高优先级的队列</span></span><br><span class="line">    Thread * nextThread = QTimeSlice_2-&gt;<span class="built_in">Remove</span>();</span><br><span class="line">    <span class="keyword">if</span> (nextThread)</span><br><span class="line">        <span class="keyword">return</span> (Thread *)nextThread;</span><br><span class="line"></span><br><span class="line">    nextThread = QTimeSlice_4-&gt;<span class="built_in">Remove</span>();</span><br><span class="line">    <span class="keyword">if</span> (nextThread)</span><br><span class="line">        <span class="keyword">return</span> (Thread *)nextThread;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (Thread *)QTimeSlice_8-&gt;<span class="built_in">Remove</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程调度相关的改动完成，然后是修改计时器相关的代码。在<em>machine&#x2F;timer.cc</em>文件中修改<em>TimerExpired</em>函数。该函数会在一个时间片（固定时间片<code>TimerTicks</code>的大小定义在<em>machine&#x2F;stat.h</em>文件中）结束的时候被调用，因此在此处对线程所使用的时间片+1。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 改动位于machine/timer.cc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> </span></span><br><span class="line"><span class="function"><span class="title">Timer::TimerExpired</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个时间片结束的时候对当前线程的时间片 + 1</span></span><br><span class="line">    currentThread-&gt;<span class="built_in">setUsedTimeSlices</span>(currentThread-&gt;<span class="built_in">getUsedTimeSlices</span>() + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// schedule the next timer device interrupt</span></span><br><span class="line">    interrupt-&gt;<span class="built_in">Schedule</span>(TimerHandler, (<span class="type">int</span>) <span class="keyword">this</span>, <span class="built_in">TimeOfNextInterrupt</span>(), </span><br><span class="line">		TimerInt);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// invoke the Nachos interrupt handler for this device</span></span><br><span class="line">    (*handler)(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后就是修改时钟中断的处理函数<em>TimerInterruptHandler</em>（位于<em>threads&#x2F;system.cc</em>文件中）。该函数会调用interrupt的<em>YieldOnReturn</em>方法，而该方法会作用在interrupt的<em>OneTick</em>函数中。<em>Onetick</em>函数（位于machine&#x2F;interrupt.cc）会调用当前线程的<em>Yield</em>函数，因此可以将当前线程赶下CPU，调度下一个线程，从而实现了时间片轮转的效果。因为在调度队列中所定义的时间片长度分别是2、4、8，所以对其他时间片的时刻不进行上下文切换。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 改动位于threads/system.cc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">TimerInterruptHandler</span><span class="params">(<span class="type">int</span> dummy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (interrupt-&gt;<span class="built_in">getStatus</span>() != IdleMode) &#123;</span><br><span class="line">        <span class="type">int</span> usedTimeSlices = currentThread-&gt;<span class="built_in">getUsedTimeSlices</span>();</span><br><span class="line">        <span class="keyword">if</span> (usedTimeSlices == <span class="number">2</span> || usedTimeSlices % <span class="number">8</span> == <span class="number">6</span>) &#123;</span><br><span class="line">            <span class="comment">// 仅在使用时间片为2，6，14，以及14 + n * 8时切换进程</span></span><br><span class="line">            interrupt-&gt;<span class="built_in">YieldOnReturn</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此非抢占的多级队列反馈算法已实现完成。</p>
<p>测试函数如下：由于使用较大的任务来测试不方便查看效果，所以利用关开中断来强制使时间推进</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 改动位于threads/threadtest.cc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_mlqs</span><span class="params">(<span class="type">int</span> tid)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (num = <span class="number">0</span>; num &lt; <span class="number">20</span>; num++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;*** thread %d looped %d times with usedTimeSlices %d\n&quot;</span>, tid, num, currentThread-&gt;<span class="built_in">getUsedTimeSlices</span>());</span><br><span class="line">        interrupt-&gt;<span class="built_in">SetLevel</span>(IntOff);</span><br><span class="line">        interrupt-&gt;<span class="built_in">Enable</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">ThreadTest4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DEBUG</span>(<span class="string">&#x27;t&#x27;</span>, <span class="string">&quot;Entering ThreadTest4\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Thread * threadbox[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        threadbox[i] = <span class="keyword">new</span> <span class="built_in">Thread</span>(<span class="string">&quot;sub_thread&quot;</span>);</span><br><span class="line">        threadbox[i]-&gt;<span class="built_in">Fork</span>(do_mlqs, (<span class="type">void</span> *)(threadbox[i]-&gt;<span class="built_in">getTid</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了方便看测试结果将<em>machine&#x2F;stats.h</em>中的固定时间片大小<code>TimerTicks</code>值改为20。部分测试结果如下：可以看到每个线程用了2个时间片就会放弃CPU，进入4时间片的队列。</p>
<img src="/2020/11/16/Nachos-Lab01-%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6/challenge_result.png" class="" title="Challenge Result">

<h2 id="遇到的困难以及解决方法"><a href="#遇到的困难以及解决方法" class="headerlink" title="遇到的困难以及解决方法"></a>遇到的困难以及解决方法</h2><ul>
<li><strong>困难1 Thread类最前面两个变量为什么一定要放在最开头且顺序固定</strong></li>
</ul>
<p>经过与同学的讨论得出结论：对于c++类，其对象内的数据成员在内存上是按照定义顺序来顺序存储的。因此栈顶指针就位于了线程对象地址偏移量为0的位置，machineState的起始地址也就位于了偏移量为4的位置。这样可以从<em>threads&#x2F;switch.s</em>文件中的汇编代码看到，将线程地址放入eax寄存器中，r然后从eax寄存器的不同偏移来存储和恢复线程的上下文，而这些偏移就正好对应了线程的栈顶指针和machineState数组中的数据。另外，将偏移量为0的位置，即线程栈顶指针，赋值给了栈顶指针寄存器esp，这样就实现了硬件对线程任务的处理。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] CSDN. nachos 3.4 实现抢占式多级队列反馈算法[EB\OL]. <a target="_blank" rel="noopener" href="https://blog.csdn.net/eaglex/article/details/6336763?locationNum=3&fps=1">https://blog.csdn.net/eaglex/article/details/6336763?locationNum=3&amp;fps=1</a></p>
<p>[2] 博韦 (Bovet, Daniel P.(Daniel Pierre)) et al. 深入理解linux内核[M]. 北京: 中国电力出版社, 2007: 261-265</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>Nachos Lab01 线程机制</p><p><a href="https://rlyown.github.io/2020/11/16/Nachos-Lab01-线程机制/">https://rlyown.github.io/2020/11/16/Nachos-Lab01-线程机制/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>Chaos Chen</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2020-11-16</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2023-06-30</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Nachos/">Nachos</a><a class="link-muted mr-2" rel="tag" href="/tags/Context-of-Execution/">Context of Execution</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/11/17/Nachos-Lab02-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Nachos Lab02 虚拟内存</span></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comentarios</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "85db7da4dd1834da6797cc2c400c047b",
            repo: "rlyown.github.io",
            owner: "Rlyown",
            clientID: "0dc9a246a80c473e7d31",
            clientSecret: "08612f9152910db6288e61191a4221bad6aea8e5",
            admin: ["Rlyown"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 20,
            pagerDirection: "last",
            
            
            enableHotKey: true,
            language: "zh-CN",
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catálogo</h3><ul class="menu-list"><li><a class="level is-mobile" href="#第一部分"><span class="level-left"><span class="level-item">1</span><span class="level-item">第一部分</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#调研"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">调研</span></span></a></li></ul></li><li><a class="level is-mobile" href="#第二部分"><span class="level-left"><span class="level-item">2</span><span class="level-item">第二部分</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Exercise1-源代码阅读"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">Exercise1 源代码阅读</span></span></a></li><li><a class="level is-mobile" href="#Exercise2-扩展线程的数据结构"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">Exercise2 扩展线程的数据结构</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#思路"><span class="level-left"><span class="level-item">2.2.1</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#实现"><span class="level-left"><span class="level-item">2.2.2</span><span class="level-item">实现</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Exercise3-增加全局线程管理机制"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">Exercise3  增加全局线程管理机制</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#思路-1"><span class="level-left"><span class="level-item">2.3.1</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#实现-1"><span class="level-left"><span class="level-item">2.3.2</span><span class="level-item">实现</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Exercise4-源代码阅读"><span class="level-left"><span class="level-item">2.4</span><span class="level-item">Exercise4 源代码阅读</span></span></a></li><li><a class="level is-mobile" href="#Exercise5-线程调度算法扩展"><span class="level-left"><span class="level-item">2.5</span><span class="level-item">Exercise5 线程调度算法扩展</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#思路-2"><span class="level-left"><span class="level-item">2.5.1</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#实现-2"><span class="level-left"><span class="level-item">2.5.2</span><span class="level-item">实现</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Challenge-线程调度算法扩展"><span class="level-left"><span class="level-item">2.6</span><span class="level-item">Challenge 线程调度算法扩展</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#思路-3"><span class="level-left"><span class="level-item">2.6.1</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#实现-3"><span class="level-left"><span class="level-item">2.6.2</span><span class="level-item">实现</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#遇到的困难以及解决方法"><span class="level-left"><span class="level-item">3</span><span class="level-item">遇到的困难以及解决方法</span></span></a></li><li><a class="level is-mobile" href="#参考资料"><span class="level-left"><span class="level-item">4</span><span class="level-item">参考资料</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/f7.png" alt="Real Own" height="28"></a><p class="is-size-7"><span>&copy; 2023 Chaos Chen</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visitado por <span id="busuanzi_value_site_uv">0</span> usuarios</span></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-hans");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Volver arriba" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "Este sitio web utiliza cookies para mejorar su experiencia.",
          dismiss: "¡Entendido!",
          allow: "Permitir cookies",
          deny: "Descenso",
          link: "Aprende más",
          policy: "Política de cookies",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Teclea algo..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Teclea algo...","untitled":"(Sin título)","posts":"Entradas","pages":"Páginas","categories":"Categorías","tags":"Etiquetas"});
        });</script></body></html>