<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Nachos Lab02 虚拟内存 - Real Own</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Chaos Chen"><meta name="msapplication-TileImage" content="/img/f7.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Chaos Chen"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="本次Lab主要涵盖了三个部分，第一部分对TLB的理解及对相关缺页中断处理方式；第二部分虚拟内存和页表之间的关联和管理方式，多进程共存内存的处理方法，以及内存缺页的处理；第三部分则是利用文件系统的交换空间，来实现不将进程一次性读入内存的延迟装载。拓展部分则是实现进程的挂起和倒排页表。"><meta property="og:type" content="blog"><meta property="og:title" content="Nachos Lab02 虚拟内存"><meta property="og:url" content="https://rlyown.github.io/2020/11/17/Nachos-Lab02-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"><meta property="og:site_name" content="Real Own"><meta property="og:description" content="本次Lab主要涵盖了三个部分，第一部分对TLB的理解及对相关缺页中断处理方式；第二部分虚拟内存和页表之间的关联和管理方式，多进程共存内存的处理方法，以及内存缺页的处理；第三部分则是利用文件系统的交换空间，来实现不将进程一次性读入内存的延迟装载。拓展部分则是实现进程的挂起和倒排页表。"><meta property="og:image" content="https://rlyown.github.io/2020/11/17/Nachos-Lab02-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/USE_TLB.png"><meta property="og:image" content="https://rlyown.github.io/2020/11/17/Nachos-Lab02-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/Assertion_failed.png"><meta property="og:image" content="https://rlyown.github.io/2020/11/17/Nachos-Lab02-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/ASSERT_Result.png"><meta property="og:image" content="https://rlyown.github.io/2020/11/17/Nachos-Lab02-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/Exercise2_Result.png"><meta property="og:image" content="https://rlyown.github.io/2020/11/17/Nachos-Lab02-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/halt.png"><meta property="og:image" content="https://rlyown.github.io/2020/11/17/Nachos-Lab02-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/FIFO_Result.png"><meta property="og:image" content="https://rlyown.github.io/2020/11/17/Nachos-Lab02-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/LRU_Result.png"><meta property="og:image" content="https://rlyown.github.io/2020/11/17/Nachos-Lab02-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/Exercise4_Result1.png"><meta property="og:image" content="https://rlyown.github.io/2020/11/17/Nachos-Lab02-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/Exercise4_Result2.png"><meta property="og:image" content="https://rlyown.github.io/2020/11/17/Nachos-Lab02-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/code_read.png"><meta property="og:image" content="https://rlyown.github.io/2020/11/17/Nachos-Lab02-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/Exercise5_Result.png"><meta property="og:image" content="https://rlyown.github.io/2020/11/17/Nachos-Lab02-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/Exercise7_Result.png"><meta property="og:image" content="https://rlyown.github.io/2020/11/17/Nachos-Lab02-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/pageTable_init.jpg"><meta property="og:image" content="https://rlyown.github.io/2020/11/17/Nachos-Lab02-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/Addrspace_pageTable_init.jpg"><meta property="og:image" content="https://rlyown.github.io/2020/11/17/Nachos-Lab02-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/AddrSpace_RestoreState.jpg"><meta property="og:image" content="https://rlyown.github.io/2020/11/17/Nachos-Lab02-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/Tid_Exit.jpg"><meta property="og:image" content="https://rlyown.github.io/2020/11/17/Nachos-Lab02-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/Challenge2_Result.jpg"><meta property="article:published_time" content="2020-11-17T13:54:07.000Z"><meta property="article:modified_time" content="2023-06-30T08:53:26.385Z"><meta property="article:author" content="Chaos Chen"><meta property="article:tag" content="Nachos"><meta property="article:tag" content="Virtual Memory"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://rlyown.github.io/2020/11/17/Nachos-Lab02-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/USE_TLB.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://rlyown.github.io/2020/11/17/Nachos-Lab02-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"},"headline":"Nachos Lab02 虚拟内存","image":["https://rlyown.github.io/2020/11/17/Nachos-Lab02-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/USE_TLB.png","https://rlyown.github.io/2020/11/17/Nachos-Lab02-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/Assertion_failed.png","https://rlyown.github.io/2020/11/17/Nachos-Lab02-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/ASSERT_Result.png","https://rlyown.github.io/2020/11/17/Nachos-Lab02-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/Exercise2_Result.png","https://rlyown.github.io/2020/11/17/Nachos-Lab02-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/halt.png","https://rlyown.github.io/2020/11/17/Nachos-Lab02-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/FIFO_Result.png","https://rlyown.github.io/2020/11/17/Nachos-Lab02-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/LRU_Result.png","https://rlyown.github.io/2020/11/17/Nachos-Lab02-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/Exercise4_Result1.png","https://rlyown.github.io/2020/11/17/Nachos-Lab02-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/Exercise4_Result2.png","https://rlyown.github.io/2020/11/17/Nachos-Lab02-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/code_read.png","https://rlyown.github.io/2020/11/17/Nachos-Lab02-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/Exercise5_Result.png","https://rlyown.github.io/2020/11/17/Nachos-Lab02-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/Exercise7_Result.png","https://rlyown.github.io/2020/11/17/Nachos-Lab02-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/pageTable_init.jpg","https://rlyown.github.io/2020/11/17/Nachos-Lab02-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/Addrspace_pageTable_init.jpg","https://rlyown.github.io/2020/11/17/Nachos-Lab02-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/AddrSpace_RestoreState.jpg","https://rlyown.github.io/2020/11/17/Nachos-Lab02-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/Tid_Exit.jpg","https://rlyown.github.io/2020/11/17/Nachos-Lab02-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/Challenge2_Result.jpg"],"datePublished":"2020-11-17T13:54:07.000Z","dateModified":"2023-06-30T08:53:26.385Z","author":{"@type":"Person","name":"Chaos Chen"},"publisher":{"@type":"Organization","name":"Real Own","logo":{"@type":"ImageObject","url":"https://rlyown.github.io/img/f7.png"}},"description":"本次Lab主要涵盖了三个部分，第一部分对TLB的理解及对相关缺页中断处理方式；第二部分虚拟内存和页表之间的关联和管理方式，多进程共存内存的处理方法，以及内存缺页的处理；第三部分则是利用文件系统的交换空间，来实现不将进程一次性读入内存的延迟装载。拓展部分则是实现进程的挂起和倒排页表。"}</script><link rel="canonical" href="https://rlyown.github.io/2020/11/17/Nachos-Lab02-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"><link rel="alternate" href="/atom.xml" title="Real Own" type="application/atom+xml"><link rel="icon" href="/img/f7.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Oxanium:wght@300;400;600&amp;family=Roboto+Mono"><link rel="stylesheet" href="/css/cyberpunk.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/f7.png" alt="Real Own" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/Rlyown/rlyown.github.io"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catálogo" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Buscar" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Publicado hace&nbsp;<time dateTime="2020-11-17T13:54:07.000Z" title="11/17/2020, 9:54:07 PM">2020-11-17</time></span><span class="level-item">Actualizado hace&nbsp;<time dateTime="2023-06-30T08:53:26.385Z" title="6/30/2023, 4:53:26 PM">2023-06-30</time></span><span class="level-item"><a class="link-muted" href="/categories/Operating-System/">Operating System</a></span><span class="level-item">an hour de lectura (Aproximadamente 7401 palabras)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>&nbsp;visitas</span></div></div><h1 class="title is-3 is-size-4-mobile">Nachos Lab02 虚拟内存</h1><div class="content"><h2 id="第一部分-TLB异常处理"><a href="#第一部分-TLB异常处理" class="headerlink" title="第一部分 TLB异常处理"></a>第一部分 TLB异常处理</h2><h3 id="Exercise1-源代码阅读"><a href="#Exercise1-源代码阅读" class="headerlink" title="Exercise1 源代码阅读"></a>Exercise1 源代码阅读</h3><blockquote>
<p>阅读code&#x2F;userprog&#x2F;progtest.cc，着重理解nachos执行用户程序的过程，以及该过程中与内存管理相关的要点</p>
</blockquote>
<p><em>Code&#x2F;userprog&#x2F;progtest.cc</em>：该文件最重要的就是<em>StartProcess</em>函数，该函数指明了如何启动用户进程。它接收一个文件名，在函数中会打开传入的可执行文件，然后为可执行文件创建地址空间（即将可执行文件内存储的信息放入内存），接着初始化寄存器以及调用<em>RestoreState</em>函数将由Addrspace类内部创建的页表指针传递给machine，最后调用<code>machine-&gt;Run()</code>函数来跳转到用户进程执行。</p>
<p>具体过程如下：</p>
<ol>
<li>在<em>StartProcess</em>中调用<em>AddrSpace</em>创建用户空间，将可执行文件读入内存</li>
<li>调用<em>InitRegisters</em>初始化寄存器，及调用<em>RestoreState</em>将用户线程的页表装入machine</li>
<li>调用<code>machine-&gt;Run()</code>执行用户线程的指令。</li>
<li>通过<em>OneInstruction</em>来执行指令。如果<em>OneInstruction</em>顺利执行，则会将PC增加，从而实现执行下一条指令。如果执行出错（即<em>ReadMem</em>和<em>WriteMem</em>出错），则会进行异常处理；异常处理结束后，由于PC并未增加，因此出现错误的指令会被再次执行。</li>
<li>当程序执行到末尾时，会执行<em>start.s</em>中的<em>Exit</em>指令。最终通过系统调用SyscallException中的SC_Exit调用，进行程序结束处理。<strong>由于进入到这里处理之后，用户程序已经执行结束，PC不会自动增加，系统（可能）会反复执行Exit调用。对于存在多用户线程的情况，需要在此处手动将PC增加，从而维持后续线程的执行。</strong></li>
</ol>
<blockquote>
<p>阅读code&#x2F;machine目录下的machine.h(cc)，translate.h(cc)文件和code&#x2F;userprog目录下的exception.h(cc)，理解当前Nachos系统所采用的TLB机制和地址转换机制。</p>
</blockquote>
<p><em>TLB机制和地址转换机制</em>：Nachos的machine中有两个指针，分别是tlb和pageTable。当tlb指针不为空时，nachos会逐一遍历tlb表，检查其内部的valid值以及虚拟页号（virtualPage）与计算出的vpn值是否一致（其中，vpn是通过对传入的虚拟地址取高25位获得，低7位代表偏移量，即磁盘块大小为128字节）。如果二者均满足，则代表tlb命中，返回<code>NoException</code>信号；否则会返回一个缺页异常（<code>PageFaultException</code>）信号。如果tlb指针为空，则会去检查<code>pageTable[vpn]</code>的valid值，并直接根据vpn获取页。获取到了虚拟页表项之后，取出其中存储的物理页框号，最后根据公式<code>physAddr = pageFrame * PageSize + offset</code>，计算得出物理地址，完成虚拟地址到物理地址的转换。</p>
<h3 id="Exercise2-TLB-MISS异常处理"><a href="#Exercise2-TLB-MISS异常处理" class="headerlink" title="Exercise2 TLB MISS异常处理"></a>Exercise2 TLB MISS异常处理</h3><blockquote>
<p>修改code&#x2F;userprog目录下exception.cc中的ExceptionHandler函数，使得Nachos系统可以对TLB异常进行处理（TLB异常时，Nachos系统会抛出PageFaultException，详见code&#x2F;machine&#x2F;machine.cc）</p>
</blockquote>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>通过阅读translate.cc文件，易得知地址转换工作就是发生在<em>Machine::Translate</em>函数中。如果转换过程中出现问题，该函数会抛出异常，如缺页异常（<code>PageFaultException</code>）。检索地址转换函数被调用的位置可以得知，该函数会被<em>ReadMem或WriteMem</em>函数调用。</p>
<p>查看这两个读写内存函数可以得知，由<em>Translate</em>返回的异常会被送入<em>RaiseException</em>函数引起异常（<code>machine-&gt;RaiseException(exception, addr);</code>）。进一步跟进到<em>RaiseException</em>函数的实现，可以看到它将产生异常的虚拟地址送入到BadVAddrReg寄存器中。</p>
<p>所以在异常处理函数<em>ExceptionHandler</em>中，新增对缺页异常的处理。然后通过读取BadVAddrReg寄存器来获取虚拟地址，从而实现从pageTable向tlb调页。</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>修改异常处理函数ExceptionHandler，增加对缺页异常的处理。关于对装载页函数<em>LoadPage</em>的实现，参见Exercise3。（注： <code>tlb[i].time</code>是为了置换算法新增的属性）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * userprog/exception.cc中的ExceptionHandler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (which == PageFaultException) &#123;</span><br><span class="line">        <span class="built_in">DEBUG</span>(<span class="string">&#x27;m&#x27;</span>, <span class="string">&quot;Page miss, swap page!\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取引发异常的虚拟地址，然后交给装载页函数处理</span></span><br><span class="line">        <span class="type">int</span> badVAddrReg = machine-&gt;<span class="built_in">ReadRegister</span>(BadVAddrReg);</span><br><span class="line">        machine-&gt;<span class="built_in">LoadPage</span>(badVAddrReg);</span><br><span class="line">  			<span class="built_in">printTLB</span>(machine-&gt;tlb, TLBSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void printTLB(TranslationEntry *tlb, int size) &#123;</span></span><br><span class="line"><span class="comment">    printf(&quot;==============TLB with size %d==============\n&quot;, size);</span></span><br><span class="line"><span class="comment">    printf(&quot;time vPg pPg valid rdOnly use dirty\n&quot;);</span></span><br><span class="line"><span class="comment">    for (int i = 0; i &lt; size; i++) &#123;</span></span><br><span class="line"><span class="comment">        printf(&quot;%d  %d  %d  %d  %d  %d  %d\n&quot;, tlb[i].time, tlb[i].virtualPage,</span></span><br><span class="line"><span class="comment">               tlb[i].physicalPage, tlb[i].valid, tlb[i].readOnly, tlb[i].use, tlb[i].dirty);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    printf(&quot;==============TLB END==============\n&quot;);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>这里的<em>LoadPage</em>使用FIFO置换算法。由于Nachos默认没有启用TLB，可以修改<em>userprog&#x2F;Makefile</em>添加<code>USE_TLE</code>的宏以启动TLB（如果发现添加了之后依然没启用TLB，参见下文<strong>困难1</strong>的解决方案）。</p>
<img src="/2020/11/17/Nachos-Lab02-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/USE_TLB.png" class="" title="ADD USE_TLB">



<p>为了更好的看效果，将TLBSize改为2。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * machine/machine.h</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TLBSize    2     <span class="comment">// if there is a TLB, make it small</span></span></span><br></pre></td></tr></table></figure>

<p>然后使用<code>./userprog/nachos -x test/halt</code>命令来进行测试（注：可以使用<code>-d am</code>参数来输出相关的debug信息，a和m代表的函数见<code>threads/utility.h</code>）。</p>
<p>如果执行出现如下错误，需要注释<em>code&#x2F;machine&#x2F;translate.cc</em>中<em>Translate</em>内部的<em>ASSERT</em>函数，因为该函数阻止了tlb和pageTable同时启用。</p>
<img src="/2020/11/17/Nachos-Lab02-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/Assertion_failed.png" class="" title="Assertion Failed">

<img src="/2020/11/17/Nachos-Lab02-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/ASSERT_Result.png" class="" title="Assertion Result">

<p>每次执行完缺页中断后输出TLB表的信息，最后测试结果如下。可以看到TLB表按照FIFO的规则替换。</p>
<img src="/2020/11/17/Nachos-Lab02-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/Exercise2_Result.png" class="" title="Exercise2 Result">



<h3 id="Exercise3-置换算法"><a href="#Exercise3-置换算法" class="headerlink" title="Exercise3 置换算法"></a>Exercise3 置换算法</h3><blockquote>
<p>为TLB机制实现至少两种置 换算法，通过比较不同算法的置换次数可比较算法的优劣。</p>
</blockquote>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>此处实现的是FIFO和LRU算法。</p>
<p>对于FIFO，使用一个属性time来记录页换入TLB的时间。置换策略为：如果TLB还有剩余空间（即存在invalid的项），则直接将新页换入；否则，淘汰TLB中最早换入的项，并换入新页。</p>
<p>对于LRU，同样使用time属性来记录页最后一次被访问的时间（或最后一次TLB命中的时间）。置换策略为：如果TLB还有剩余空间（即存在invalid的项），则直接将新页换入；否则，淘汰TLB中最近最久未被访问的项，并换入新页。</p>
<p>这个时间可以使用stats中记录的总时间totalTicks。并且由于该值是<code>int</code>类型，FIFO和LRU均等价于查找time属性最小的项进行淘汰。</p>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>首先实现一个通用（不仅适用与tlb也适用内存缺页）的装载函数LoadPage对缺页进行处理，这里暂时只考虑对TLB缺页进行处理，而不考虑内存缺页的情况，因此调度算法中均假定需要访问的页均在页表中。在此处实现了FIFO和LRU两种置换算法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * machine/machine.h中的Machine类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">		<span class="comment">// tlb缺页处理函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">TlbSwap_FIFO</span> <span class="params">(<span class="type">unsigned</span> <span class="type">int</span> vpn)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">TlbSwap_LRU</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> vpn)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 页装载处理函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">LoadPage</span><span class="params">(<span class="type">int</span> virtAddr)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中<em>LoadPage</em>中同时考虑了页表缺页和tlb缺页两种情况。如果没有启用tlb，则必然是内存页表缺页；如果启用了tlb，也需要考虑内存页表是否缺页，先处理内存缺页，再处理tlb缺页。因此此处暂不考虑内存缺页的情况，因此相关的处理代码暂时先不写。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Machine::LoadPage</span><span class="params">(<span class="type">int</span> virtAddr)</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> vpn = (<span class="type">unsigned</span>) virtAddr / PageSize;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> offset = (<span class="type">unsigned</span>) virtAddr % PageSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (machine-&gt;tlb == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果tlb为NULL引发PageFaultException的原因是pageTable[vpn].valid为false</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 此时表明tlb未命中，因此执行tlb置换策略</span></span><br><span class="line">        <span class="keyword">if</span> (!(machine-&gt;pageTable[vpn]).valid) &#123;</span><br><span class="line">            <span class="comment">/* 如果页表也缺页，先给页表调页 */</span></span><br><span class="line"><span class="comment">//            printf(&quot;=====&gt; %s Page Table Swap！\n&quot;, currentThread-&gt;getName());</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为tlb调页</span></span><br><span class="line"><span class="comment">//        printf(&quot;=====&gt; %s TLB Swap！\n&quot;, currentThread-&gt;getName());</span></span><br><span class="line">        <span class="built_in">TlbSwap_LRU</span>(vpn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>对于FIFO算法，需要记录每个转换表项换入TLB中的时间，所以转换表项TranslationEntry类中增加一个time的变量，用于记录每个表项换入TLB的时间。其时间值来自于stats对象中记录的totalTicks值。FIFO算法的实现思路为：遍历TLB表，如果出现未使用的项（即valid为FALSE），则直接从pageTable复制信息到TLB中，并记录换入的时间；如果所有的项均使用（即valid为TRUE），则根据规则，选择淘汰最早被换入的项，然后换入新表项。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Machine::TlbSwap_FIFO</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> vpn)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> min_tlb_in_time = <span class="number">0x7fffffff</span>;</span><br><span class="line">    <span class="type">int</span> min_idx = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; TLBSize; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!tlb[i].valid) &#123;</span><br><span class="line">            <span class="comment">// pageTableSize缺页的情况暂不考虑</span></span><br><span class="line">            <span class="built_in">swap_from_pgtable_to_TLB</span>(tlb[i], pageTable[vpn]);</span><br><span class="line">            tlb[i].time = stats-&gt;totalTicks;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tlb[i].time &lt; min_tlb_in_time)&#123;</span><br><span class="line">            min_idx = i;</span><br><span class="line">            min_tlb_in_time = tlb[i].time;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果i与TLBSize相等则说明，TLB中所有的项都是valid，此时需要淘汰掉最早进入的项</span></span><br><span class="line">    <span class="keyword">if</span> (i == TLBSize) &#123;</span><br><span class="line">        <span class="built_in">swap_from_pgtable_to_TLB</span>(tlb[min_idx], pageTable[vpn]);</span><br><span class="line">        tlb[min_idx].time = stats-&gt;totalTicks;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void swap_from_pgtable_to_TLB(TranslationEntry &amp;tlbEntry, TranslationEntry &amp;pgTableEntry) &#123;</span></span><br><span class="line"><span class="comment">    tlbEntry.virtualPage = pgTableEntry.virtualPage;</span></span><br><span class="line"><span class="comment">    tlbEntry.physicalPage = pgTableEntry.physicalPage;</span></span><br><span class="line"><span class="comment">    tlbEntry.valid = TRUE;</span></span><br><span class="line"><span class="comment">    tlbEntry.readOnly = pgTableEntry.readOnly;</span></span><br><span class="line"><span class="comment">    tlbEntry.use = pgTableEntry.use;</span></span><br><span class="line"><span class="comment">    tlbEntry.dirty = pgTableEntry.dirty;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>对于LRU算法，也是使用变量time来记录每个表项最后一次被访问的时间，然后该值会在<em>Translate</em>函数中被更新，即每次TLB命中时，会同时更新最后被访问的时间。LRU算法在实现上与FIFO算法完全一致，唯一的区别就是LRU会在TLB命中时更新time的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * machine/translate.cc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (entry = <span class="literal">NULL</span>, i = <span class="number">0</span>; i &lt; TLBSize; i++)</span><br><span class="line">  			<span class="keyword">if</span> (tlb[i].valid &amp;&amp; (tlb[i].virtualPage == vpn)) &#123;</span><br><span class="line">		entry = &amp;tlb[i];			<span class="comment">// FOUND!</span></span><br><span class="line">		<span class="comment">// LRU算法，更新访问时间</span></span><br><span class="line">		tlb[i].time = stats-&gt;totalTicks;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="两种置换算法的比较"><a href="#两种置换算法的比较" class="headerlink" title="两种置换算法的比较"></a>两种置换算法的比较</h5><p>使用<em>test&#x2F;halt</em>进行测试。由于halt仅是一个空程序，只占用很少的页，所以修改器程序代码，对一个二位数组按行遍历，代码如下图。</p>
<img src="/2020/11/17/Nachos-Lab02-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/halt.png" class="" title="test&#x2F;halt">

<p>然后在<em>machine&#x2F;machine.h</em>中添加两个计数变量，并在<em>machine&#x2F;translate.cc</em>的头部将其初始化为0。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// machine/machine.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> TLBMissCount;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> TranslateCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">// machine/translate.cc顶部</span></span><br><span class="line"><span class="type">int</span> TLBMissCount = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> TranslateCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// machine/translate.cc中Translate，在未命中处累加</span></span><br><span class="line"><span class="keyword">if</span> (entry == <span class="literal">NULL</span>) &#123;				<span class="comment">// not found</span></span><br><span class="line">	  TLBMissCount++;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// machine/translate.cc中Translate，进入该函数就累加</span></span><br><span class="line">TranslateCount++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// userprog/exception中ExceptionHandler，</span></span><br><span class="line"><span class="comment">// 因为全面提到的halt程序执行了Halt函数，所以在Halt异常处打印统计结果</span></span><br><span class="line">    <span class="keyword">if</span> (which == SyscallException) &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == SC_Halt) &#123;</span><br><span class="line">            <span class="built_in">DEBUG</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&quot;Shutdown, initiated by user program.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;TLB Miss: %d, TLB Hit: %d, Total Translate: %d, TLB Miss Rate: %.2lf%%\n&quot;</span>,</span><br><span class="line">                  TLBMissCount, TranslateCount-TLBMissCount, TranslateCount, (<span class="type">double</span>)(TLBMissCount*<span class="number">100</span>)/(TranslateCount));</span><br><span class="line">            interrupt-&gt;<span class="built_in">Halt</span>();</span><br></pre></td></tr></table></figure>

<p>测试halt程序结果如下（这里仍是以TlbSize为2进行测试的）：</p>
<p>FIFO置换算法</p>
<img src="/2020/11/17/Nachos-Lab02-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/FIFO_Result.png" class="" title="FIFO Result">

<p>LRU算法</p>
<img src="/2020/11/17/Nachos-Lab02-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/LRU_Result.png" class="" title="LRU Result">

<p>相比之下，可以看到LRU算法的缺页率略低于FIFO算法。</p>
<h2 id="第二部分-分页式内存管理"><a href="#第二部分-分页式内存管理" class="headerlink" title="第二部分 分页式内存管理"></a>第二部分 分页式内存管理</h2><h3 id="Exercise-4-内存全局管理数据结构"><a href="#Exercise-4-内存全局管理数据结构" class="headerlink" title="Exercise 4 内存全局管理数据结构"></a>Exercise 4 内存全局管理数据结构</h3><blockquote>
<p>设计并实现一个全局性的数据结构（如空闲链表、位图等）来进行内存的分配和回收，并记录当前内存的使用状态。</p>
</blockquote>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>在Machine类中新增一个位图数据结构来管理内存空间。然后在每次分配物理页的时候，先从位图中查找一块未使用的物理页并在位图中将其置1，然后返回物理块号并将页表项设为valid。反之，在回收的时候，直接在位图中将该物理页置0，并将页表项设为invalid。</p>
<h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><p>考虑到Nachos中已经实现了一个位图的数据结构，位于<em>userprog&#x2F;bitmap.h(cc)<em>中。因此直接在</em>machine.h</em>文件中<code>#include &quot;bitmap.h&quot;</code>，并且在Machine类中添加用于内存管理的位图指针memBitMap（<code>BitMap *memBitMap;</code>）。因为调用的都是BitMap中的方法，为了简便将该指针设为public。该指针在Machine构造函数中被初始化，其位图的大小为物理页数量<code>NumPhysPages</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * machine/machine.cc中Machine构造函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">memBitMap = <span class="keyword">new</span> <span class="built_in">BitMap</span>(NumPhysPages);</span><br></pre></td></tr></table></figure>

<p>由<em>progtest.cc</em>文件可知，用户进程在Addrspace中初始化用户空间，因此修改Addrspace类的构造函数。对pageTable初始化的部分，将物理页的分配改为从内存位图中获取第一个未分配（即位值为0）的物理页。此处加上了断言函数，因为如果位图没有找到值为0的位，则会返回-1。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * userprog/addrspace.cc中的Addrspace构造函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> phyPage = machine-&gt;memBitMap-&gt;<span class="built_in">Find</span>();</span><br><span class="line"><span class="built_in">DEBUG</span>(<span class="string">&#x27;m&#x27;</span>, <span class="string">&quot;Physical memory page %d is allocated!\n&quot;</span>, phyPage);</span><br><span class="line"><span class="built_in">ASSERT</span>(phyPage != <span class="number">-1</span>);</span><br><span class="line">pageTable[i].physicalPage = phyPage;</span><br></pre></td></tr></table></figure>

<p>紧接着改造<em>exception.cc</em>中的异常处理函数。由该函数可知，Nachos仅实现了Halt调用的处理，没有对Exit调用（即用户进程退出时执行的系统调用）的处理。因此增加Exit调用的处理，并实现从内存位图中回收所有的物理页，然后对将要结束的进程执行*Finish()*方法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (which == SyscallException) &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == SC_Halt) &#123;</span><br><span class="line">            <span class="built_in">DEBUG</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&quot;Shutdown, initiated by user program.\n&quot;</span>);</span><br><span class="line">            interrupt-&gt;<span class="built_in">Halt</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == SC_Exit) &#123;</span><br><span class="line">            <span class="built_in">DEBUG</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&quot;User program Exit！\n&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (currentThread-&gt;space != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; machine-&gt;pageTableSize; i++) &#123;</span><br><span class="line">                    <span class="comment">// 回收物理空间</span></span><br><span class="line">                    <span class="type">int</span> phyPage = machine-&gt;pageTable[i].physicalPage;</span><br><span class="line">                    <span class="built_in">DEBUG</span>(<span class="string">&#x27;m&#x27;</span>, <span class="string">&quot;Physical memory page %d is cleared!\n&quot;</span>, phyPage);</span><br><span class="line">                    machine-&gt;memBitMap-&gt;<span class="built_in">Clear</span>(phyPage);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 此处本质上是实现了exit系统调用</span></span><br><span class="line">                <span class="comment">// 回收space空间，执行进程Finish函数</span></span><br><span class="line">                <span class="keyword">delete</span> currentThread-&gt;space;</span><br><span class="line">                currentThread-&gt;space = <span class="literal">NULL</span>;</span><br><span class="line">                currentThread-&gt;<span class="built_in">Finish</span>();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果如下（因为使用了DEBUG方式来输出信息，因此截图中省略了与该实现无关的信息）：</p>
<img src="/2020/11/17/Nachos-Lab02-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/Exercise4_Result1.png" class="" title="Exercise4 Result1">

<img src="/2020/11/17/Nachos-Lab02-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/Exercise4_Result2.png" class="" title="Exercise4 Result2">

<h3 id="Exercise-5-多线程支持"><a href="#Exercise-5-多线程支持" class="headerlink" title="Exercise 5  多线程支持"></a>Exercise 5  多线程支持</h3><blockquote>
<p>目前Nachos系统的内存中同时只能存在一个线程，我们希望打破这种限制，使得Nachos系统支持多个线程同时存在于内存中。</p>
</blockquote>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>因为Addrspace类涉及用户空间的创建，因此阅读它的相关代理来了解用户程序是如何被读入内存的。查看Addrspace的构造函数可以发现，它创建用户空间的时候会先把内存写0，然后将可执行程序的代码（code）以及数据初始化部分（initData）完整地顺序写入内存。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * userprog/addrspace.cc中Addrspace构造函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// zero out the entire address space, to zero the unitialized data segment </span></span><br><span class="line"><span class="comment">// and the stack segment</span></span><br><span class="line">    <span class="built_in">bzero</span>(machine-&gt;mainMemory, size);</span><br><span class="line">...</span><br><span class="line">  </span><br><span class="line"> <span class="keyword">if</span> (noffH.code.size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="built_in">DEBUG</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&quot;Initializing code segment, at 0x%x, size %d\n&quot;</span>, </span><br><span class="line">		 noffH.code.virtualAddr, noffH.code.size);</span><br><span class="line">     executable-&gt;<span class="built_in">ReadAt</span>(&amp;(machine-&gt;mainMemory[noffH.code.virtualAddr]),</span><br><span class="line">				noffH.code.size, noffH.code.inFileAddr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (noffH.initData.size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">DEBUG</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&quot;Initializing data segment, at 0x%x, size %d\n&quot;</span>, </span><br><span class="line">			noffH.initData.virtualAddr, noffH.initData.size);</span><br><span class="line">      executable-&gt;<span class="built_in">ReadAt</span>(&amp;(machine-&gt;mainMemory[noffH.initData.virtualAddr]),</span><br><span class="line">					noffH.initData.size, noffH.initData.inFileAddr);</span><br></pre></td></tr></table></figure>

<p>所以为了实现多线程同时存在内存，需要让用户数据支持按页离散存放。可以采取逐字节读取数据，然后计算其存放的物理地址并存入内存。</p>
<h4 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h4><p>基于上一个Exercise实现的内存全局管理，使得用户进程允许离散位置的物理空间分配。但是在Addrspace的构造函数中可以看到，创建一个用户进程的时候会把内存空间置零。因此如果要支持多个进程同时存在内存，需要将该行代码<code>bzero(...)</code>注释。</p>
<p>然后修改可执行程序的代码写入内存的方式。原来的方法是按照虚拟内存来一次性线性写入内存，但是这种方式不适合多线程的支持。因此按照下述的方式，以字节为单位把内容一一写入到进程所分配到的物理页当中。简单来说就是读取每一个字节，然后根据页表计算物理地址，最后在其内写入数据，其中物理页号由之前位图分配给页表。对于code部分处理方式如下图，initData的处理方式类似。</p>
<img src="/2020/11/17/Nachos-Lab02-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/code_read.png" class="" title="noffH.code">

<p>最后修改exception.cc中的Exit系统调用处理部分，在处理的最后加入下述代码，使PC+4从而切换到下一个线程。（这里暂时没弄清楚为什么PC+4可以引发进程切换）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * userprog/exception.cc中SC_Exit</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// PC + 4</span></span><br><span class="line"><span class="type">int</span> nextPc = machine-&gt;<span class="built_in">ReadRegister</span>(NextPCReg);</span><br><span class="line">machine-&gt;<span class="built_in">WriteRegister</span>(PCReg, nextPc);</span><br></pre></td></tr></table></figure>

<p>另外当进程切换时，需要将该进程所有的TLB项失效。因此在SaveState时将所有的TLB项设为invalid。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * userprog/addrspace.cc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddrSpace::SaveState</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 因为上下文切换时，旧进程的TLB全部失效，因此全部置为invalid</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; TLBSize; i++) &#123;</span><br><span class="line">        machine-&gt;tlb[i].valid = FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后修改测试函数，让它能够同时执行两个线程：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * userprog/progtest.cc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// multi process test</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestMultiProc</span><span class="params">(<span class="type">char</span> *filename)</span> </span>&#123;</span><br><span class="line">    Thread * thread_1 = <span class="keyword">new</span> <span class="built_in">Thread</span>(<span class="string">&quot;thread 1&quot;</span>);</span><br><span class="line">    Thread * thread_2 = <span class="keyword">new</span> <span class="built_in">Thread</span>(<span class="string">&quot;thread 2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    thread_1-&gt;<span class="built_in">setPriority</span>(<span class="number">10</span>);</span><br><span class="line">    thread_2-&gt;<span class="built_in">setPriority</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    thread_1-&gt;<span class="built_in">Fork</span>(StartProcess, (<span class="type">void</span> *)filename);</span><br><span class="line">    thread_2-&gt;<span class="built_in">Fork</span>(StartProcess, (<span class="type">void</span> *)filename);</span><br><span class="line"></span><br><span class="line">    currentThread-&gt;<span class="built_in">Yield</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时main.cc也要做修改，以调用<em>TestMultiProc</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * threads/main.cc中main</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USER_PROGRAM</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(*argv, <span class="string">&quot;-x&quot;</span>)) &#123;            <span class="comment">// run a user program</span></span><br><span class="line">       <span class="built_in">ASSERT</span>(argc &gt; <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">TestMultiProc</span>(*(argv + <span class="number">1</span>));</span><br><span class="line">            argCount = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>测试结果如下：</p>
<img src="/2020/11/17/Nachos-Lab02-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/Exercise5_Result.png" class="" title="Exercise5 Result">

<h3 id="Exercise-6-缺页中断处理"><a href="#Exercise-6-缺页中断处理" class="headerlink" title="Exercise 6  缺页中断处理"></a>Exercise 6  缺页中断处理</h3><blockquote>
<p>基于TLB机制的异常处理和页面替换算法的实践，实现缺页中断处理（注意！TLB机制的异常处理是将内存中已有的页面调入TLB，而此处的缺页中断处理则是从磁盘中调入新的页面到内存）、页面替换算法等。</p>
</blockquote>
<h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p>设计一个所有进程都能访问到的全局交换空间。该空间可以利用文件系统fileSystem来创建，从而实现内存页面被换出到磁盘上，或磁盘上的页换入到内存中。</p>
<p>同时该交换空间需要一个管理机制，可以参照物理页的分配一样使用位图管理。同时还需要在页表项中新增一个交换地址，用于查找被换出到交换空间的页。</p>
<h4 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h4><p>首先在Nachos中实现一个简易的交换分区。在Machine类中增加两个公共成员，交换分区位图swapBitMap，以及交换分区的磁盘文件swapFile。并在Machine构造函数中将其初始化为内存的两倍大小，另外交换分区一页的大小与内存一页大小相等。以及在~Machine析构函数中将它们删除。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * machine/machine.h中Machine类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BitMap *swapBitMap;  <span class="comment">// 交换页位图</span></span><br><span class="line">OpenFile *swapFile;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * machine/machine.cc中Machine构造函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">swapBitMap = <span class="keyword">new</span> <span class="built_in">BitMap</span>(NumPhysPages * <span class="number">2</span>);</span><br><span class="line">fileSystem-&gt;<span class="built_in">Create</span>(<span class="string">&quot;VirtualMemory&quot;</span>, MemorySize * <span class="number">2</span>);</span><br><span class="line">swapFile = fileSystem-&gt;<span class="built_in">Open</span>(<span class="string">&quot;VirtualMemory&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * machine/machine.cc中~Machine析构函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">delete</span> swapBitMap;</span><br><span class="line">fileSystem-&gt;<span class="built_in">Remove</span>(<span class="string">&quot;VirtualMemory&quot;</span>);</span><br><span class="line"><span class="keyword">delete</span> swapFile;</span><br></pre></td></tr></table></figure>

<p>然后给页表项的结构中加入swapPage成员，用于记录当前页存储在交换分区的页号，在初始化的时候swapPage的值为-1。该值与valid值不同时使用，即当分配物理页使得valid为TRUE时，页调入内存中，交换分区会回收之前分配给该页的空间。因此如果要将页从内存换出到交换分区时，需要重新分配交换分区页。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * machine/translate.h</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TranslationEntry</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> time;  <span class="comment">// 用于置换算法的凭据，</span></span><br><span class="line">    <span class="comment">// 对于FIFO是记录该项进入tlb或者页表的时间，</span></span><br><span class="line">    <span class="comment">// 对于LRU是记录该项最近被访问的时间</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> swapPage;  <span class="comment">// 交换分区页号，它和valid不能共存，即如果有物理块号，则必然不会有交换分区页号</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> virtualPage;   <span class="comment">// The page number in virtual memory.</span></span><br><span class="line">    <span class="type">int</span> physicalPage;      <span class="comment">// The page number in real memory (relative to the</span></span><br><span class="line">         <span class="comment">//  start of &quot;mainMemory&quot;</span></span><br><span class="line">    <span class="type">bool</span> valid;         <span class="comment">// If this bit is set, the translation is ignored.</span></span><br><span class="line">         <span class="comment">// (In other words, the entry hasn&#x27;t been initialized.)</span></span><br><span class="line">    <span class="type">bool</span> readOnly; <span class="comment">// If this bit is set, the user program is not allowed</span></span><br><span class="line">         <span class="comment">// to modify the contents of the page.</span></span><br><span class="line">    <span class="type">bool</span> use;           <span class="comment">// This bit is set by the hardware every time the</span></span><br><span class="line">         <span class="comment">// page is referenced or modified.</span></span><br><span class="line">    <span class="type">bool</span> dirty;         <span class="comment">// This bit is set by the hardware every time the</span></span><br><span class="line">         <span class="comment">// page is modified.</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>缺页中断的设计建立在之前的TLB的基础上，为TLB调页之前，需要检查页表中的页是否存在，如果不存在则从虚拟内存文件中进行调页。</p>
<p>对于页表调页算法，分为两部分。如果内存中有还未分配的内存空间，则从内存位图中获取物理页号，并从虚拟内存文件中读取数据写入到该物理页中。如果内存中不存在未分配的空间，则使用LRU算法进行调页。</p>
<p>而LRU算法的实现，与TLB中的LRU算法实现方式一致，均使用time变量来记录每次命中时的访问时间，然后选择最早被访问的项淘汰。但是页表的置换还需考虑是否要将内存中的页写回磁盘。因此如果页的dirty位为<code>TRUE</code>，则获取交换分区的一页空间，并将该物理页的数据写入到交换分区中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Machine::LoadPage</span><span class="params">(<span class="type">int</span> virtAddr)</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> vpn = (<span class="type">unsigned</span>) virtAddr / PageSize;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> offset = (<span class="type">unsigned</span>) virtAddr % PageSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (machine-&gt;tlb == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果tlb为NULL引发PageFaultException的原因是pageTable[vpn].valid为false</span></span><br><span class="line">        <span class="built_in">PageTableSwap</span>(vpn);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 此时表明tlb未命中，因此执行tlb置换策略</span></span><br><span class="line">        <span class="keyword">if</span> (!(machine-&gt;pageTable[vpn]).valid) &#123;</span><br><span class="line">            <span class="comment">/* 如果页表也缺页，先给页表调页 */</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;=====&gt; %s Page Table Swap！\n&quot;</span>, currentThread-&gt;<span class="built_in">getName</span>());</span><br><span class="line">            <span class="built_in">PageTableSwap</span>(vpn);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为tlb调页</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;=====&gt; %s TLB Swap！\n&quot;</span>, currentThread-&gt;<span class="built_in">getName</span>());</span><br><span class="line">        <span class="built_in">TlbSwap_LRU</span>(vpn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Machine::PageTableSwap</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> vpn)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> phyPage = memBitMap-&gt;<span class="built_in">Find</span>();</span><br><span class="line">    <span class="keyword">if</span> (phyPage == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果没找到物理页，则使用置换算法找到被换出的页</span></span><br><span class="line">        phyPage = <span class="built_in">PageTableSwap_LRU</span>(vpn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从交换分区取出数据，并回收该交换页</span></span><br><span class="line">    <span class="type">int</span> spn = pageTable[vpn].swapPage;</span><br><span class="line">    swapFile-&gt;<span class="built_in">ReadAt</span>(&amp;(mainMemory[phyPage * PageSize]), PageSize, spn * PageSize);</span><br><span class="line">    swapBitMap-&gt;<span class="built_in">Clear</span>(spn);  <span class="comment">// 回收该页</span></span><br><span class="line"></span><br><span class="line">    pageTable[vpn].swapPage = <span class="number">-1</span>;</span><br><span class="line">    pageTable[vpn].valid = TRUE;</span><br><span class="line">    pageTable[vpn].physicalPage = phyPage;</span><br><span class="line">    pageTable[vpn].use = FALSE;</span><br><span class="line">    pageTable[vpn].dirty = FALSE;</span><br><span class="line">    pageTable[vpn].readOnly = FALSE;</span><br><span class="line">    pageTable[vpn].time = stats-&gt;totalTicks;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Machine::PageTableSwap_LRU</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> vpn)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> min_pgTable_last_time = <span class="number">0x7fffffff</span>;</span><br><span class="line">    <span class="type">int</span> min_idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pageTableSize; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pageTable[i].time &lt; min_pgTable_last_time) &#123;</span><br><span class="line">            min_idx = i;</span><br><span class="line">            min_pgTable_last_time = pageTable[i].time;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 给待换出的页分配交换分区号</span></span><br><span class="line">    <span class="type">int</span> spn = swapBitMap-&gt;<span class="built_in">Find</span>(); <span class="built_in">ASSERT</span>(spn != <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (pageTable[min_idx].dirty) &#123;</span><br><span class="line">        swapFile-&gt;<span class="built_in">WriteAt</span>(&amp;(mainMemory[pageTable[min_idx].physicalPage * PageSize]),</span><br><span class="line">                        PageSize, spn * PageSize);</span><br><span class="line">    &#125;</span><br><span class="line">    pageTable[min_idx].swapPage = spn;</span><br><span class="line">    pageTable[min_idx].valid = FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pageTable[min_idx].physicalPage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该部分是与Exercise一同实现的，所以待Lazy-loading实现后再作测试。</p>
<h2 id="第三部分-Lazy-loading"><a href="#第三部分-Lazy-loading" class="headerlink" title="第三部分 Lazy-loading"></a>第三部分 Lazy-loading</h2><h3 id="Exercise-7"><a href="#Exercise-7" class="headerlink" title="Exercise 7"></a>Exercise 7</h3><blockquote>
<p>我们已经知道，Nachos系统为用户程序分配内存必须在用户程序载入内存时一次性完成，故此，系统能够运行的用户程序的大小被严格限制在4KB以下。请实现Lazy-loading的内存分配算法，使得当且仅当程序运行过程中缺页中断发生时，才会将所需的页面从磁盘调入内存。</p>
</blockquote>
<h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p>上一个练习实现了交换分区，因此考虑将可执行文件读入内存时，不将所有内容读入到内存，而是将所有（或一部分）页先存储在交换分区。仅当发生缺页中断时才从交换分区调页到内存。</p>
<p>需要注意的是，Addrspace类的构造函数中仅将代码<code>code</code>和初始数据<code>initdata</code>两个部分做了处理。因此将他们写入交换分区之后，还需要保证其余的留给用户栈<code>UserStackSize</code>和未初始化数据<code>uninitData</code>的空间也被分配到交换分区。</p>
<p>否则，用户栈<code>UserStackSize</code>和未初始化数据<code>uninitData</code>的空间是未被分配任何空间的（交换分区还未分配，内存中也不分配）。<strong>这样就会导致，内存调页去写入用户栈或者数据的时候，可能会写在一个未被分配的空间上，从而引发问题。</strong></p>
<h4 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h4><p>修改Addrspace类的构造函数，在用户程序初始化的时候，不读入内存，而是全部采用读入到交换分区的操作。直到用户程序执行引发了缺页中断，才从交换分区调页到内存中。因此在分配页表的时候对每一个页都分配一个交换分区号sp。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * code/userprog/addrspace.cc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">AddrSpace::<span class="built_in">AddrSpace</span>(OpenFile *executable)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    pageTable = <span class="keyword">new</span> TranslationEntry[numPages];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numPages; i++) &#123;</span><br><span class="line">...</span><br><span class="line">					<span class="type">int</span> sp = machine-&gt;swapBitMap-&gt;<span class="built_in">Find</span>(); <span class="built_in">ASSERT</span>(sp != <span class="number">-1</span>);</span><br><span class="line">					pageTable[i].swapPage = sp;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后对<code>noffH.code</code>和<code>noffH.initData</code>做处理，即现将数据写入到交换分区。观察代码可以发现，其写入方式与物理页几乎完全一致，区别仅在于写入的位置是交换分区文件，而不是物理内存。<code>noffH.initData</code>的处理方式与<code>noffH.code</code>一致。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * userprog/addrspace.cc中Addrspace构造函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">if</span> (noffH.code.size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">DEBUG</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&quot;Initializing code segment, at 0x%x, size %d\n&quot;</span>, </span><br><span class="line">			noffH.code.virtualAddr, noffH.code.size);</span><br><span class="line">      </span><br><span class="line">        <span class="type">int</span> pos_file = noffH.code.inFileAddr;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> cur_char;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> p = <span class="number">0</span>; p &lt; noffH.code.size; p++) &#123;</span><br><span class="line">            <span class="type">int</span> cur_vpn = (noffH.code.virtualAddr + p) / PageSize;</span><br><span class="line">            <span class="type">int</span> cur_spn = pageTable[cur_vpn].swapPage;</span><br><span class="line">            <span class="type">int</span> swap_offset = (noffH.code.virtualAddr + p) % PageSize;</span><br><span class="line"></span><br><span class="line">            executable-&gt;<span class="built_in">ReadAt</span>(&amp;(cur_char), <span class="number">1</span>, pos_file++);</span><br><span class="line">            machine-&gt;swapFile-&gt;<span class="built_in">WriteAt</span>(&amp;(cur_char), <span class="number">1</span>, cur_spn * PageSize + swap_offset);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>测试结果如下：</p>
<img src="/2020/11/17/Nachos-Lab02-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/Exercise7_Result.png" class="" title="Exercise7 Result">

<h2 id="第四部分-Challenges"><a href="#第四部分-Challenges" class="headerlink" title="第四部分 Challenges"></a>第四部分 Challenges</h2><h3 id="Challenge-1"><a href="#Challenge-1" class="headerlink" title="Challenge 1"></a>Challenge 1</h3><blockquote>
<p>为线程增加挂起SUSPENDED状态，并在已完成的文件系统和内存管理功能的基础之上，实现线程在“SUSPENDED”，“READY”和“BLOCKED”状态之间的切换。</p>
</blockquote>
<h3 id="Challenge-2"><a href="#Challenge-2" class="headerlink" title="Challenge 2"></a>Challenge 2</h3><blockquote>
<p>多级页表的缺陷在于页表的大小与虚拟地址空间的大小成正比，为了节省物理内存在页表存储上的消耗，请在Nachos系统中实现倒排页表。 </p>
</blockquote>
<h4 id="实现-6"><a href="#实现-6" class="headerlink" title="实现"></a>实现</h4><p>倒排页表主要完成的是根据物理地址来查找页表项，因此全局仅需要一个倒排页表。修改Machine类的构造函数，将其内的pageTable改造为倒排页表。设置pageTable的大小为物理页数量，并初始化其内的值。</p>
 <img src="/2020/11/17/Nachos-Lab02-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/pageTable_init.jpg" class="" title="pageTable Init">

<p>与此同时，需要在页表项的结构中添加tid，用于标示该物理页属于哪个进程。</p>
<p>然后修改物理页的分配方式，修改Addrpace的构造函数，删除其内部创建的pageTable，而是直接使用machine中的全局倒排页表，其中物理页号与页表下标一致。</p>
 <img src="/2020/11/17/Nachos-Lab02-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/Addrspace_pageTable_init.jpg" class="" title="Addrspace pageTable Init"> 

<p>由于此时全局仅有一张页表，因此不需要替换machine中的页表指针，所以将RestoreState函数注释。</p>
 <img src="/2020/11/17/Nachos-Lab02-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/AddrSpace_RestoreState.jpg" class="" title="AddrSpace RestoreState"> 

<p>最后，在异常处理函数ExceptionHandler中修改，页回收的方式。根据tid搜索页表中属于该线程的页，并将其回收。</p>
 <img src="/2020/11/17/Nachos-Lab02-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/Tid_Exit.jpg" class="" title="Exit by tid"> 



<p>最后测试结果如下：</p>
 <img src="/2020/11/17/Nachos-Lab02-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/Challenge2_Result.jpg" class="" title="Challenge2 Result"> 

<p>可以看到仅分配给进程的部分有tid，且valid的值为1，满足倒排页表的可能结果。</p>
<h2 id="遇到的困难以及解决方法"><a href="#遇到的困难以及解决方法" class="headerlink" title="遇到的困难以及解决方法"></a>遇到的困难以及解决方法</h2><h3 id="困难1-在Makefile增加USE-TLB宏之后，tlb的值依然为NULL"><a href="#困难1-在Makefile增加USE-TLB宏之后，tlb的值依然为NULL" class="headerlink" title="困难1 在Makefile增加USE_TLB宏之后，tlb的值依然为NULL"></a>困难1 在Makefile增加USE_TLB宏之后，tlb的值依然为NULL</h3><p>增加多处DEBUG信息，检查tlb的初始化以及调用，但仍得到如下信息。在无意中修改了#ifdef USE_TLB中的代码之后发现，TLB的值不为NULL了。</p>
<p>解决办法：执行make clean清除掉之前编译留下的.o文件，然后重新make。如果出现报错说“bin&#x2F;csh: not found”，那么修改code&#x2F;Makefile将其中的csh修改为sh。</p>
<p>经过分析得知，在编译之后保留了编译好的那些.o文件以加快后续的编译速度，但也正是保留了这些静态目标文件，从而导致了修改Makefile增加USE_TLB宏不生效。猜测Makefile自动检测改动只考虑代码的变动，而不考虑Makefile自身的变动，从而导致对Makefile的改动不生效。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] 百度文库. Nachos虚拟内存机制实习报告[EB&#x2F;OL]. <a target="_blank" rel="noopener" href="https://wenku.baidu.com/view/ee473599964bcf84b9d57b89.html">https://wenku.baidu.com/view/ee473599964bcf84b9d57b89.html</a></p>
<p>[2] Github. 1200012964_彭广举_虚拟内存实习报告.pdf[EB&#x2F;OL]. <a target="_blank" rel="noopener" href="https://github.com/BACKPGJ/nachos/blob/master/homework/1200012964_%E5%BD%AD%E5%B9%BF%E4%B8%BE_%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%AE%9E%E4%B9%A0%E6%8A%A5%E5%91%8A.pdf">https://github.com/BACKPGJ/nachos/blob/master/homework/1200012964_%E5%BD%AD%E5%B9%BF%E4%B8%BE_%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%AE%9E%E4%B9%A0%E6%8A%A5%E5%91%8A.pdf</a></p>
<p>[3] CSDN. Nachos实习——Lab2虚拟内存实习报告[EB&#x2F;OL]. <a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_40875078/article/details/109472895">https://blog.csdn.net/sinat_40875078/article/details/109472895</a></p>
<p>[4] 百度文库. nachos Lab4实习报告[EB&#x2F;OL]. <a target="_blank" rel="noopener" href="https://wenku.baidu.com/view/be56dfe2541810a6f524ccbff121dd36a32dc430.html">https://wenku.baidu.com/view/be56dfe2541810a6f524ccbff121dd36a32dc430.html</a></p>
</div><div class="article-licensing box"><div class="licensing-title"><p>Nachos Lab02 虚拟内存</p><p><a href="https://rlyown.github.io/2020/11/17/Nachos-Lab02-虚拟内存/">https://rlyown.github.io/2020/11/17/Nachos-Lab02-虚拟内存/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>Chaos Chen</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2020-11-17</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2023-06-30</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Nachos/">Nachos</a><a class="link-muted mr-2" rel="tag" href="/tags/Virtual-Memory/">Virtual Memory</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/11/22/Nachos-Lab03-%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Nachos Lab03 同步机制</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/11/16/Nachos-Lab01-%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6/"><span class="level-item">Nachos Lab01 线程机制</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comentarios</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "f78efc9b382632aefc435c8cd7ed162f",
            repo: "rlyown.github.io",
            owner: "Rlyown",
            clientID: "0dc9a246a80c473e7d31",
            clientSecret: "08612f9152910db6288e61191a4221bad6aea8e5",
            admin: ["Rlyown"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 20,
            pagerDirection: "last",
            
            
            enableHotKey: true,
            language: "zh-CN",
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catálogo</h3><ul class="menu-list"><li><a class="level is-mobile" href="#第一部分-TLB异常处理"><span class="level-left"><span class="level-item">1</span><span class="level-item">第一部分 TLB异常处理</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Exercise1-源代码阅读"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">Exercise1 源代码阅读</span></span></a></li><li><a class="level is-mobile" href="#Exercise2-TLB-MISS异常处理"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">Exercise2 TLB MISS异常处理</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#思路"><span class="level-left"><span class="level-item">1.2.1</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#实现"><span class="level-left"><span class="level-item">1.2.2</span><span class="level-item">实现</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Exercise3-置换算法"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">Exercise3 置换算法</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#思路-1"><span class="level-left"><span class="level-item">1.3.1</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#实现-1"><span class="level-left"><span class="level-item">1.3.2</span><span class="level-item">实现</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#两种置换算法的比较"><span class="level-left"><span class="level-item">1.3.2.1</span><span class="level-item">两种置换算法的比较</span></span></a></li></ul></li></ul></li></ul></li><li><a class="level is-mobile" href="#第二部分-分页式内存管理"><span class="level-left"><span class="level-item">2</span><span class="level-item">第二部分 分页式内存管理</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Exercise-4-内存全局管理数据结构"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">Exercise 4 内存全局管理数据结构</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#思路-2"><span class="level-left"><span class="level-item">2.1.1</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#实现-2"><span class="level-left"><span class="level-item">2.1.2</span><span class="level-item">实现</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Exercise-5-多线程支持"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">Exercise 5  多线程支持</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#思路-3"><span class="level-left"><span class="level-item">2.2.1</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#实现-3"><span class="level-left"><span class="level-item">2.2.2</span><span class="level-item">实现</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Exercise-6-缺页中断处理"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">Exercise 6  缺页中断处理</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#思路-4"><span class="level-left"><span class="level-item">2.3.1</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#实现-4"><span class="level-left"><span class="level-item">2.3.2</span><span class="level-item">实现</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#第三部分-Lazy-loading"><span class="level-left"><span class="level-item">3</span><span class="level-item">第三部分 Lazy-loading</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Exercise-7"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">Exercise 7</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#思路-5"><span class="level-left"><span class="level-item">3.1.1</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#实现-5"><span class="level-left"><span class="level-item">3.1.2</span><span class="level-item">实现</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#第四部分-Challenges"><span class="level-left"><span class="level-item">4</span><span class="level-item">第四部分 Challenges</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Challenge-1"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">Challenge 1</span></span></a></li><li><a class="level is-mobile" href="#Challenge-2"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">Challenge 2</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#实现-6"><span class="level-left"><span class="level-item">4.2.1</span><span class="level-item">实现</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#遇到的困难以及解决方法"><span class="level-left"><span class="level-item">5</span><span class="level-item">遇到的困难以及解决方法</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#困难1-在Makefile增加USE-TLB宏之后，tlb的值依然为NULL"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">困难1 在Makefile增加USE_TLB宏之后，tlb的值依然为NULL</span></span></a></li></ul></li><li><a class="level is-mobile" href="#参考文献"><span class="level-left"><span class="level-item">6</span><span class="level-item">参考文献</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/f7.png" alt="Real Own" height="28"></a><p class="is-size-7"><span>&copy; 2023 Chaos Chen</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visitado por <span id="busuanzi_value_site_uv">0</span> usuarios</span></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-hans");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Volver arriba" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "Este sitio web utiliza cookies para mejorar su experiencia.",
          dismiss: "¡Entendido!",
          allow: "Permitir cookies",
          deny: "Descenso",
          link: "Aprende más",
          policy: "Política de cookies",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Teclea algo..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Teclea algo...","untitled":"(Sin título)","posts":"Entradas","pages":"Páginas","categories":"Categorías","tags":"Etiquetas"});
        });</script></body></html>