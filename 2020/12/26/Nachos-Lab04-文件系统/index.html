<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Nachos Lab04 文件系统 - Real Own</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Chaos Chen"><meta name="msapplication-TileImage" content="/img/f7.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Chaos Chen"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="在这次文件系统的实习中主要是在Nachos内部实现的一个不完善的真实文件系统之上补充其功能。在第一部分中，主要通过对文件头和目录的修改，实现了文件描述属性的维护，文件数据块的间接索引，多级目录的处理，以及允许文件动态扩充大小。而第二部分则是，学习同步磁盘的处理方式，来实现更为精细化的同一磁盘区块读写的同步处理，以及多线程访问同一文件的一致性处理。"><meta property="og:type" content="blog"><meta property="og:title" content="Nachos Lab04 文件系统"><meta property="og:url" content="https://rlyown.github.io/2020/12/26/Nachos-Lab04-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"><meta property="og:site_name" content="Real Own"><meta property="og:description" content="在这次文件系统的实习中主要是在Nachos内部实现的一个不完善的真实文件系统之上补充其功能。在第一部分中，主要通过对文件头和目录的修改，实现了文件描述属性的维护，文件数据块的间接索引，多级目录的处理，以及允许文件动态扩充大小。而第二部分则是，学习同步磁盘的处理方式，来实现更为精细化的同一磁盘区块读写的同步处理，以及多线程访问同一文件的一致性处理。"><meta property="og:image" content="https://rlyown.github.io/2020/12/26/Nachos-Lab04-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20201219122026801.png"><meta property="og:image" content="https://rlyown.github.io/2020/12/26/Nachos-Lab04-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20201220154733266.png"><meta property="og:image" content="https://rlyown.github.io/2020/12/26/Nachos-Lab04-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20201220154944341.png"><meta property="og:image" content="https://rlyown.github.io/2020/12/26/Nachos-Lab04-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20201224172809826.png"><meta property="og:image" content="https://rlyown.github.io/2020/12/26/Nachos-Lab04-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20201226123644740.png"><meta property="og:image" content="https://rlyown.github.io/2020/12/26/Nachos-Lab04-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20201226124721667.png"><meta property="og:image" content="https://rlyown.github.io/2020/12/26/Nachos-Lab04-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20201226130757395.png"><meta property="og:image" content="https://rlyown.github.io/2020/12/26/Nachos-Lab04-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20201226160701579.png"><meta property="og:image" content="https://rlyown.github.io/2020/12/26/Nachos-Lab04-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20201231163600188.png"><meta property="og:image" content="https://rlyown.github.io/2020/12/26/Nachos-Lab04-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20201231164825409.png"><meta property="og:image" content="https://rlyown.github.io/2020/12/26/Nachos-Lab04-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20201216162750699.png"><meta property="article:published_time" content="2020-12-26T08:25:07.000Z"><meta property="article:modified_time" content="2023-06-30T08:53:26.385Z"><meta property="article:author" content="Chaos Chen"><meta property="article:tag" content="Nachos"><meta property="article:tag" content="FileSystem"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://rlyown.github.io/2020/12/26/Nachos-Lab04-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20201219122026801.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://rlyown.github.io/2020/12/26/Nachos-Lab04-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},"headline":"Nachos Lab04 文件系统","image":["https://rlyown.github.io/2020/12/26/Nachos-Lab04-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20201219122026801.png","https://rlyown.github.io/2020/12/26/Nachos-Lab04-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20201220154733266.png","https://rlyown.github.io/2020/12/26/Nachos-Lab04-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20201220154944341.png","https://rlyown.github.io/2020/12/26/Nachos-Lab04-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20201224172809826.png","https://rlyown.github.io/2020/12/26/Nachos-Lab04-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20201226123644740.png","https://rlyown.github.io/2020/12/26/Nachos-Lab04-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20201226124721667.png","https://rlyown.github.io/2020/12/26/Nachos-Lab04-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20201226130757395.png","https://rlyown.github.io/2020/12/26/Nachos-Lab04-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20201226160701579.png","https://rlyown.github.io/2020/12/26/Nachos-Lab04-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20201231163600188.png","https://rlyown.github.io/2020/12/26/Nachos-Lab04-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20201231164825409.png","https://rlyown.github.io/2020/12/26/Nachos-Lab04-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20201216162750699.png"],"datePublished":"2020-12-26T08:25:07.000Z","dateModified":"2023-06-30T08:53:26.385Z","author":{"@type":"Person","name":"Chaos Chen"},"publisher":{"@type":"Organization","name":"Real Own","logo":{"@type":"ImageObject","url":"https://rlyown.github.io/img/f7.png"}},"description":"在这次文件系统的实习中主要是在Nachos内部实现的一个不完善的真实文件系统之上补充其功能。在第一部分中，主要通过对文件头和目录的修改，实现了文件描述属性的维护，文件数据块的间接索引，多级目录的处理，以及允许文件动态扩充大小。而第二部分则是，学习同步磁盘的处理方式，来实现更为精细化的同一磁盘区块读写的同步处理，以及多线程访问同一文件的一致性处理。"}</script><link rel="canonical" href="https://rlyown.github.io/2020/12/26/Nachos-Lab04-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"><link rel="alternate" href="/atom.xml" title="Real Own" type="application/atom+xml"><link rel="icon" href="/img/f7.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Oxanium:wght@300;400;600&amp;family=Roboto+Mono"><link rel="stylesheet" href="/css/cyberpunk.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/f7.png" alt="Real Own" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/Rlyown/rlyown.github.io"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Publié il y a&nbsp;<time dateTime="2020-12-26T08:25:07.000Z" title="12/26/2020, 4:25:07 PM">2020-12-26</time></span><span class="level-item">Mis à jour il y a&nbsp;<time dateTime="2023-06-30T08:53:26.385Z" title="6/30/2023, 4:53:26 PM">2023-06-30</time></span><span class="level-item"><a class="link-muted" href="/categories/Operating-System/">Operating System</a></span><span class="level-item">an hour de lecture (Environ 11652 mots)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>&nbsp;visites</span></div></div><h1 class="title is-3 is-size-4-mobile">Nachos Lab04 文件系统</h1><div class="content"><h2 id="文件系统的基本操作"><a href="#文件系统的基本操作" class="headerlink" title="文件系统的基本操作"></a>文件系统的基本操作</h2><h3 id="Exercise-1-源代码阅读"><a href="#Exercise-1-源代码阅读" class="headerlink" title="Exercise 1 源代码阅读"></a>Exercise 1 源代码阅读</h3><blockquote>
<p>阅读Nachos源代码中与文件系统相关的代码，理解Nachos文件系统的工作原理。</p>
<p>code&#x2F;filesys&#x2F;filesys.h和code&#x2F;filesys&#x2F;filesys.cc</p>
<p>code&#x2F;filesys&#x2F;filehdr.h和code&#x2F;filesys&#x2F;filehdr.cc </p>
<p>code&#x2F;filesys&#x2F;directory.h和code&#x2F;filesys&#x2F;directory.cc </p>
<p>code&#x2F;filesys&#x2F;openfile.h和code&#x2F;filesys&#x2F;openfile.cc </p>
<p>code&#x2F;userprog&#x2F;bitmap.h和code&#x2F;userprog&#x2F;bitmap.cc </p>
</blockquote>
<ul>
<li><p><em>code&#x2F;filesys&#x2F;filesys.h和code&#x2F;filesys&#x2F;filesys.cc</em>：这里是文件系统的实现，文件系统是存储在磁盘上的，按目录组织的一组文件，提供了根据文件名来创建、打开、删除操作。文件系统包含两个重要数据结构空闲空间位图以及目录。而对于文件系统上的每个文件均包含文件头、数据块数量和目录项。</p>
<p>该文件系统存在两个实现版本“STUB”和“REAL”。“STUB”版本只是将文件系统定义为运行在Nachos中的对本机Unix文件系统的操作；“REAL”版本是在磁盘模拟器上构建的文件系统，其利用本机Unix文件系统来模拟磁盘（DISK）。</p>
</li>
<li><p><em>code&#x2F;filesys&#x2F;filehdr.h和code&#x2F;filesys&#x2F;filehdr.cc</em>：这里是关于文件头结构的定义和实现。一个文件头部描述了如何在磁盘上获取文件数据，以及长度，所有者等等信息。</p>
</li>
<li><p><em>code&#x2F;filesys&#x2F;directory.h和code&#x2F;filesys&#x2F;directory.cc</em>：这里是目录和目录项的定义和实现。目录是一个表用于记录&lt;文件名，扇区号&gt;数据对，提供目录中的文件名及其文件头所在磁盘位置的信息。</p>
</li>
<li><p><em>code&#x2F;filesys&#x2F;openfile.h和code&#x2F;filesys&#x2F;openfile.cc</em> ：这里是文件结构的定义和实现。提供了打开，关闭，读写等文件操作方法。此处同样提供了两种实现版本“STUB”和“REAL”。</p>
</li>
<li><p><em>code&#x2F;userprog&#x2F;bitmap.h和code&#x2F;userprog&#x2F;bitmap.cc</em> ：这两个文件用于实现一个位图结构。该位图支持对某个一个位进行设置（Mark）、清除（Clear）和测试是否设置（Test），以及从位图中查找一个Clear值（Find）和Clear所有的值（NumClear）。除此之外，还支持持久化存储，即将位图保存到文件（WriteBack）以及从文件还原位图数据（FetchFrom）。</p>
</li>
</ul>
<h3 id="Exercise-2-扩展文件属性"><a href="#Exercise-2-扩展文件属性" class="headerlink" title="Exercise 2 扩展文件属性"></a>Exercise 2 扩展文件属性</h3><blockquote>
<p>增加文件描述信息，如“类型”、“创建时间”、“上次访问时间”、“上次修改时间”、“路径”等等。尝试突破文件名长度的限制。</p>
</blockquote>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>这里需要注意的是，从文件系统的Create方法以及文件头的WriteBack方法中可以看到，初始的文件头仅用了一个磁盘块存储，也就是说<strong>文件头FileHeader的大小不能超过一个磁盘块大小（128 Bytes）</strong>。</p>
<p><strong>文件磁盘块数量</strong>。在<em>filehdr.h</em>中设置了一个宏<code>NumDirect</code>用于记录一个文件头部能够存储的直接磁盘块数量。FileHeader仅放在一个磁盘块中，并且记录两个整数numBytes和numSectors，剩余空间均为该文件头可记录的磁盘块。如果修改了FileHeader的数据结构，如增加描述信息，则需要<strong>修改该宏避免数据溢出</strong>。对于目录文件也存在DirectoryEntry数据结构大小影响目录条目存储上限的问题，但由于预设数量仅为10（定义于<em>code&#x2F;filesys&#x2F;filesys.cc</em>文件中的<code>#define NumDirEntries 10</code>）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NumDirect 	((SectorSize - 2 * sizeof(int)) / sizeof(int))</span></span><br></pre></td></tr></table></figure>

<p><strong>突破文件名长度</strong>。如果仍是采取文件名定长的方式，仅修改<code>FileNameMaxLen</code>该宏的大小，则不影响。但是如果换成了不定长的文件名，则需要对下列函数中的<em>strncmp</em>字符串比较函数（定长比较）修改为<em>strcmp</em>函数（不定长比较）。可能存在这一问题的还有<em>Directory::Add</em>中的<em>strncpy</em>函数（是否需要修改看不定长文件名的实现方式）。</p>
<p>不定长的文件名存在一个较为麻烦的问题：<strong>将变量（如目录）写回磁盘的时候，写回的是文件名的指针，而不是字符串。这也就意味着，当Nachos执行结束之后，再次执行，所有的文件名会失效。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">Directory::FindIndex</span><span class="params">(<span class="type">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; tableSize; i++)</span><br><span class="line">        <span class="keyword">if</span> (table[i].inUse &amp;&amp; !<span class="built_in">strncmp</span>(table[i].name, name, FileNameMaxLen))</span><br><span class="line">       <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;    <span class="comment">// name not in directory</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span></span></span><br><span class="line"><span class="function"><span class="title">Directory::Add</span><span class="params">(<span class="type">char</span> *name, <span class="type">int</span> newSector)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">FindIndex</span>(name) != <span class="number">-1</span>)</span><br><span class="line">	<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; tableSize; i++)</span><br><span class="line">        <span class="keyword">if</span> (!table[i].inUse) &#123;</span><br><span class="line">            table[i].inUse = TRUE;</span><br><span class="line">            <span class="built_in">strncpy</span>(table[i].name, name, FileNameMaxLen); </span><br><span class="line">            table[i].sector = newSector;</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> FALSE;	<span class="comment">// no space.  Fix when we have extensible files.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试函数</strong>。由于此时还未实现动态文件大小，因此fstest中的测试函数中利用文件系统创建文件时，不能将初始大小设为0。否则会出现无法写入，或无法读取的情况。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> </span></span><br><span class="line"><span class="function"><span class="title">FileWrite</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (!fileSystem-&gt;<span class="built_in">Create</span>(FileName, <span class="number">0</span>)) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Perf test: can&#x27;t create %s\n&quot;</span>, FileName);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>结合Exercise 1中阅读的信息可以得知，文件的描述信息可以考虑在目录项或者文件头中记录。这里为了后续实现的方便，描述信息部分放在FileHeader文件头中，另一部分放在目录项中。</p>
<p>因此在<em>filehdr.h</em>文件中文件头FileHeader类中添加文件描述信息的私有成员crtTime、lastAccTime、lastModTime，以及相应的set和get方法。而路径则通过在文件中记录父文件夹文件头所处的磁盘块号（parDirHeaderSector）来进行反向查询。</p>
<p>而对于<em>directory.h</em>文件中的目录条目DirectoryEntry则新增文件类型和路径两个数据。文件类型目前仅分为普通文件（F_NORMAL）和目录文件（F_DIRECTORY）两种。</p>
<p>关于文件名长度限制。可以发现，仅在目录文件的目录项结构中出现了关于文件名的记录，并且使用了<code>FileNameMaxLen</code>常量来限制最大文件长度。因此可以通过将固定长度的字符数组修改为指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * code/filesys/filehdr.h </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileHeader</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getCrtTime</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> crtTime;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setCrtTime</span><span class="params">(<span class="type">int</span> ct)</span> </span>&#123;crtTime = ct;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getLastAccTime</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> lastAccTime;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setLastAccTime</span><span class="params">(<span class="type">int</span> lat)</span> </span>&#123;lastAccTime = lat;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getLastModTime</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> lastModTime;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setLastModTime</span><span class="params">(<span class="type">int</span> lmt)</span> </span>&#123;lastModTime = lmt;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getParDirHeaderSector</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> parDirHeaderSector;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setParDirHeaderSector</span><span class="params">(<span class="type">int</span> pds)</span> </span>&#123;parDirHeaderSector = pds;&#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">...</span><br><span class="line">    <span class="type">int</span> crtTime;        <span class="comment">// 创建时间</span></span><br><span class="line">    <span class="type">int</span> lastAccTime;    <span class="comment">// 最后访问时间</span></span><br><span class="line">    <span class="type">int</span> lastModTime;    <span class="comment">// 最后修改时间</span></span><br><span class="line">    <span class="type">int</span> parDirHeaderSector;  <span class="comment">// 父文件夹文件头所处的磁盘块号</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * code/filesys/directory.h</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">FileType</span> &#123;</span><br><span class="line">    F_NORMAL,    <span class="comment">// 普通文件</span></span><br><span class="line">    F_DIRECTORY    <span class="comment">// 目录文件</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DirectoryEntry</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">bool</span> inUse;				<span class="comment">// Is this directory entry in use?</span></span><br><span class="line">    <span class="type">int</span> sector;				<span class="comment">// Location on disk to find the </span></span><br><span class="line">					<span class="comment">//   FileHeader for this file </span></span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> * name;</span><br><span class="line">    FileType fileType;  <span class="comment">// 文件类型</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后在FileHeader的初始化函数<em>Allocate</em>中初始化文件的描述信息。其中文件创建时间crtTime设置为当前的系统时间，并且分别在<em>FetchFrom</em>中更新最近访问时间，和<em>WriteBack</em>中更新最近修改时间。而parDirHeaderSector的初始化则是由FileSystem类来负责，所以此处为了避免出错，在创建的时候让其具有初值-1。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * code/filesys/filehdr.cc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">bool</span></span></span><br><span class="line"><span class="function"><span class="title">FileHeader::Allocate</span><span class="params">(BitMap *freeMap, <span class="type">int</span> fileSize)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">...</span><br><span class="line">    crtTime = stats-&gt;totalTicks;</span><br><span class="line">    lastModTime = crtTime;</span><br><span class="line">    lastAccTime = crtTime;</span><br><span class="line">    parDirHeaderSector = <span class="number">-1</span>;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">FileHeader::FetchFrom</span><span class="params">(<span class="type">int</span> sector)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    synchDisk-&gt;<span class="built_in">ReadSector</span>(sector, (<span class="type">char</span> *)<span class="keyword">this</span>);</span><br><span class="line">    lastAccTime = stats-&gt;totalTicks;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">FileHeader::WriteBack</span><span class="params">(<span class="type">int</span> sector)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    synchDisk-&gt;<span class="built_in">WriteSector</span>(sector, (<span class="type">char</span> *)<span class="keyword">this</span>);</span><br><span class="line">    lastModTime = stats-&gt;totalTicks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在Directory中对parDirHeaderSector初始化，则需要在Directory类的<em>Add</em>方法中从文件头所在的磁盘块中读取文件头信息，然后修改parDirHeaderSector值，再将其写回磁盘。由于经历了一次磁盘读写，这样做的效率会比较低。所以考虑在文件创建的时候，同时对路径信息初始化。</p>
<p>因此对FileSystem类中的<em>Create</em>方法进行修改，当文件创建成功且文件头还未写回磁盘时，向文件头设置父文件夹磁盘块号。此时还未实现多级目录，所以默认设为<code>DirectorySector</code>宏，该宏记录了根目录的文件头。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * code/filesys/filesys.cc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">bool</span></span></span><br><span class="line"><span class="function"><span class="title">FileSystem::Create</span><span class="params">(<span class="type">char</span> *name, <span class="type">int</span> initialSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">       <span class="keyword">else</span> &#123; </span><br><span class="line">          success = TRUE;      </span><br><span class="line">          hdr-&gt;<span class="built_in">setParDirHeaderSector</span>(DirectorySector);</span><br><span class="line">      <span class="comment">// everthing worked, flush all changes back to disk</span></span><br><span class="line">              hdr-&gt;<span class="built_in">WriteBack</span>(sector);       </span><br><span class="line">              directory-&gt;<span class="built_in">WriteBack</span>(directoryFile);</span><br><span class="line">              freeMap-&gt;<span class="built_in">WriteBack</span>(freeMapFile);</span><br><span class="line">       &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>目录条目DirectoryEntry中新增的信息也在Directory中对其初始化。重载Directory的<em>Add</em>方法，新增传入文件类型，用于对文件类型进行初始化。在<em>Add</em>中对于不定长的文件名的处理方式就是通过<em>new</em>来动态申请一个空间来存放文件名。因为文件名是动态的，因此在移除文件的时候，也需要在<em>Remove</em>中使用<em>delete</em>进行删除。</p>
<p>为了辅助路径功能的实现，添加了一个<em>FindName</em>方法，用于根据文件头的磁盘块号获取文件名。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * code/filesys/directory.h</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Directory</span> &#123;</span><br><span class="line">...</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Add</span><span class="params">(<span class="type">char</span> *name, <span class="type">int</span> newSector, FileType fileType)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> * <span class="title">FindName</span><span class="params">(<span class="type">int</span> fSector)</span></span>;  <span class="comment">// 根据磁盘块号获取文件名</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * code/filesys/directory.cc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">bool</span></span></span><br><span class="line"><span class="function"><span class="title">Directory::Add</span><span class="params">(<span class="type">char</span> *name, <span class="type">int</span> newSector, FileType fileType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">FindIndex</span>(name) != <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; tableSize; i++)</span><br><span class="line">        <span class="keyword">if</span> (!table[i].inUse) &#123;</span><br><span class="line">            table[i].inUse = TRUE;</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> lens = <span class="built_in">strlen</span>(name);</span><br><span class="line">            table[i].name = <span class="keyword">new</span> <span class="type">char</span> [lens + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strncpy</span>(table[i].name, name, lens);</span><br><span class="line">            table[i].name[lens] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            </span><br><span class="line">            table[i].sector = newSector;</span><br><span class="line">            table[i].fileType = fileType;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span></span></span><br><span class="line"><span class="function"><span class="title">Directory::Remove</span><span class="params">(<span class="type">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">int</span> i = <span class="built_in">FindIndex</span>(name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">-1</span>)</span><br><span class="line">	<span class="keyword">return</span> FALSE; 		<span class="comment">// name not in directory</span></span><br><span class="line">    table[i].inUse = FALSE;</span><br><span class="line">    <span class="keyword">delete</span> table[i].name;</span><br><span class="line">    <span class="keyword">return</span> TRUE;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span> * <span class="title">Directory::FindName</span><span class="params">(<span class="type">int</span> fSector)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; tableSize; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (table[i].inUse &amp;&amp; table[i].sector == fSector) &#123;</span><br><span class="line">            <span class="keyword">return</span> table[i].name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在<em>code&#x2F;filesys&#x2F;filesys.h</em>中新增一个PrintPath函数。通过提供当前的文件的文件名（name）以及其所属文件夹的文件头磁盘块号（parDirHeaderSector），来进行反向查询文件路径。</p>
<img src="/2020/12/26/Nachos-Lab04-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20201219122026801.png" class="" title="路径查询方式">

<p>其反向查询的思路为，以当前文件的文件夹为起点，向上获取<strong>目录的父目录</strong>的信息，然后根据这个目录的父目录去获取当前目录的目录名。查询过程如上图所示。此处省略了路径字符串的反向处理，因此路径的显示与实际相反。即Unix下<code>/usr/a</code>，而Nachos下<code>a/usr/</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * code/filesys/filesys.h</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileSystem</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PrintPath</span><span class="params">(<span class="type">int</span> parDirHeaderSector, <span class="type">char</span> * name)</span></span>;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * code/filesys/filesys.cc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FileSystem::PrintPath</span><span class="params">(<span class="type">int</span> sector, <span class="type">char</span> * name)</span> </span>&#123;</span><br><span class="line">    FileHeader *hdr;</span><br><span class="line">    OpenFile * dirFile;</span><br><span class="line">    Directory * directory;</span><br><span class="line">    <span class="type">int</span> parSector;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s/&quot;</span>, name);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sector == <span class="number">-1</span>) sector = DirectorySector;</span><br><span class="line">        hdr = <span class="keyword">new</span> FileHeader;</span><br><span class="line">        hdr-&gt;<span class="built_in">FetchFrom</span>(sector);</span><br><span class="line"></span><br><span class="line">        parSector = hdr-&gt;<span class="built_in">getParDirHeaderSector</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (parSector != <span class="number">-1</span>) &#123;</span><br><span class="line">            dirFile = <span class="keyword">new</span> <span class="built_in">OpenFile</span>(parSector);  <span class="comment">// hdr表示当前目录，其记录的是目录的父目录</span></span><br><span class="line">            directory = <span class="keyword">new</span> <span class="built_in">Directory</span>(NumDirEntries);</span><br><span class="line">            directory-&gt;<span class="built_in">FetchFrom</span>(dirFile);</span><br><span class="line">            name = directory-&gt;<span class="built_in">FindName</span>(sector);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s/&quot;</span>, name);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">delete</span> dirFile;</span><br><span class="line">            <span class="keyword">delete</span> directory;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sector = parSector;</span><br><span class="line">        <span class="keyword">delete</span> hdr;</span><br><span class="line">    &#125; <span class="keyword">while</span> (sector != DirectorySector &amp;&amp; sector != <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>做完上述修改之后，为了避免出现问题，对源代码进行一定的修改。由于FileHeader新增了数据成员，大小发生了变化，因此修改<em>code&#x2F;filesys&#x2F;filehdr.h</em>文件中的<code>NumDirect</code>宏，重新计算新的值。</p>
<p>另外，由于将文件名换成了指针，变成了不定长，所以修改<em>code&#x2F;filesys&#x2F;directory.cc</em>文件中的<em>FindIndex</em>函数中调用的定长<em>strncmp</em>字符串比较函数替换为支持不定长比较的<em>strcmp</em>函数。以及将同文件中的<em>Add</em>函数中的<em>strncpy</em>修改为指针赋值（字符串常量存储在静态存储区，因此函数结束时空间不会被回收）。</p>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>然后此时修改测试函数，将文件初始大小设为<code>FileSize</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * code/filesys/fstest.cc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> </span></span><br><span class="line"><span class="function"><span class="title">FileWrite</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (!fileSystem-&gt;<span class="built_in">Create</span>(FileName, FileSize)) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为方便查看效果，在<em>code&#x2F;filesys&#x2F;filehdr.h</em>的FileHeader中新增PrintFileDesc方法，用于打印文件头内存储的信息，并在测试函数<em>PerformanceTest（位于code&#x2F;filesys&#x2F;fstest.cc）</em>中执行的读写操作成功时调用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FileHeader::PrintFileDesc</span><span class="params">(<span class="type">char</span> * name)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;File stat contents in FileHeader. \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;CreateTime %d, Last Access Time %d, Last Modify Time %d\n&quot;</span>,</span><br><span class="line">           crtTime, lastAccTime, lastModTime);</span><br><span class="line">    fileSystem-&gt;<span class="built_in">PrintPath</span>(parDirHeaderSector, name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">root@02487b68b87e:/nachos/nachos-3.4/code/filesys<span class="comment"># ./nachos -t</span></span><br><span class="line">Starting file system performance <span class="built_in">test</span>:</span><br><span class="line">Ticks: total 1130, idle 1000, system 130, user 0</span><br><span class="line">Disk I/O: reads 2, writes 0</span><br><span class="line">Console I/O: reads 0, writes 0</span><br><span class="line">Paging: faults 0</span><br><span class="line">Network I/O: packets received 0, sent 0</span><br><span class="line">Sequential write of 50 byte file, <span class="keyword">in</span> 10 byte chunks</span><br><span class="line">Write numBytes -&gt; 10</span><br><span class="line">File <span class="built_in">stat</span> contents <span class="keyword">in</span> FileHeader. </span><br><span class="line">CreateTime 3150, Last Access Time 67210, Last Modify Time 3150</span><br><span class="line">TestFile/</span><br><span class="line">Write numBytes -&gt; 10</span><br><span class="line">File <span class="built_in">stat</span> contents <span class="keyword">in</span> FileHeader. </span><br><span class="line">CreateTime 3150, Last Access Time 67210, Last Modify Time 3150</span><br><span class="line">TestFile/</span><br><span class="line">Write numBytes -&gt; 10</span><br><span class="line">File <span class="built_in">stat</span> contents <span class="keyword">in</span> FileHeader. </span><br><span class="line">CreateTime 3150, Last Access Time 67210, Last Modify Time 3150</span><br><span class="line">TestFile/</span><br><span class="line">Write numBytes -&gt; 10</span><br><span class="line">File <span class="built_in">stat</span> contents <span class="keyword">in</span> FileHeader. </span><br><span class="line">CreateTime 3150, Last Access Time 67210, Last Modify Time 3150</span><br><span class="line">TestFile/</span><br><span class="line">Write numBytes -&gt; 10</span><br><span class="line">File <span class="built_in">stat</span> contents <span class="keyword">in</span> FileHeader. </span><br><span class="line">CreateTime 3150, Last Access Time 67210, Last Modify Time 3150</span><br><span class="line">TestFile/</span><br><span class="line">Sequential <span class="built_in">read</span> of 50 byte file, <span class="keyword">in</span> 10 byte chunks</span><br><span class="line">Read numBytes -&gt; 10</span><br><span class="line">File <span class="built_in">stat</span> contents <span class="keyword">in</span> FileHeader. </span><br><span class="line">CreateTime 3150, Last Access Time 149770, Last Modify Time 3150</span><br><span class="line">TestFile/</span><br><span class="line">Read numBytes -&gt; 10</span><br><span class="line">File <span class="built_in">stat</span> contents <span class="keyword">in</span> FileHeader. </span><br><span class="line">CreateTime 3150, Last Access Time 149770, Last Modify Time 3150</span><br><span class="line">TestFile/</span><br><span class="line">Read numBytes -&gt; 10</span><br><span class="line">File <span class="built_in">stat</span> contents <span class="keyword">in</span> FileHeader. </span><br><span class="line">CreateTime 3150, Last Access Time 149770, Last Modify Time 3150</span><br><span class="line">TestFile/</span><br><span class="line">Read numBytes -&gt; 10</span><br><span class="line">File <span class="built_in">stat</span> contents <span class="keyword">in</span> FileHeader. </span><br><span class="line">CreateTime 3150, Last Access Time 149770, Last Modify Time 3150</span><br><span class="line">TestFile/</span><br><span class="line">Read numBytes -&gt; 10</span><br><span class="line">File <span class="built_in">stat</span> contents <span class="keyword">in</span> FileHeader. </span><br><span class="line">CreateTime 3150, Last Access Time 149770, Last Modify Time 3150</span><br><span class="line">TestFile/</span><br><span class="line">Ticks: total 194530, idle 191710, system 2820, user 0</span><br><span class="line">Disk I/O: reads 37, writes 12</span><br><span class="line">Console I/O: reads 0, writes 0</span><br><span class="line">Paging: faults 0</span><br><span class="line">Network I/O: packets received 0, sent 0</span><br><span class="line">No threads ready or runnable, and no pending interrupts.</span><br><span class="line">Assuming the program completed.</span><br><span class="line">Machine halting!</span><br><span class="line"></span><br><span class="line">Ticks: total 194540, idle 191720, system 2820, user 0</span><br><span class="line">Disk I/O: reads 37, writes 12</span><br><span class="line">Console I/O: reads 0, writes 0</span><br><span class="line">Paging: faults 0</span><br><span class="line">Network I/O: packets received 0, sent 0</span><br><span class="line"></span><br><span class="line">Cleaning up...</span><br></pre></td></tr></table></figure>



<h3 id="Exercise-3-扩展文件长度"><a href="#Exercise-3-扩展文件长度" class="headerlink" title="Exercise 3 扩展文件长度"></a>Exercise 3 扩展文件长度</h3><blockquote>
<p>改直接索引为间接索引，以突破文件长度不能超过4KB的限制。</p>
</blockquote>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>将部分直接索引块替换成多级索引块，为方便实现可以仅考虑实现一级索引。一张索引表用一个磁盘块存储，因此需要有一个索引表结构处理该磁盘块上的数据。</p>
<p>然后分别对涉及文件大小的三个函数<em>FileHeader::Allocate</em>、<em>FileHeader::Deallocate</em>、<em>FileHeader::ByteToSector</em>进行处理以适应新的文件数据块索引方式。</p>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>拓展文件长度的方式则是参照Unix文件系统的方式，在文件头中注册一定数量的直接索引，以及一部分的间接索引块。这次为了实现方便，仅使用一级索引和直接索引。</p>
<p>首先在<em>code&#x2F;filesys&#x2F;filehdr.h</em>中添加一些宏，添加宏的主要用途就是定义一级索引表的数量，然后修改直接索引宏的数量计算公式。此处分配了7个磁盘块指针用于存储一级索引表，剩余的20个指针则全部用于直接索引。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * code/filesys/filehdr.h</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 索引表条目数，其中扇区号用整数存储，此时的值为32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NumTableEntry (SectorSize / sizeof(int))  </span></span><br><span class="line"><span class="comment">// 一级索引表数量</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NumTable_LV1 7 </span></span><br><span class="line"><span class="comment">// 一级索引表最大存储大小</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxTableSize_LV1 (NumTable_LV1 * NumTableEntry * SectorSize) </span></span><br><span class="line"><span class="comment">// 直接索引块数量，此时的值为20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NumDirect  ((SectorSize - 5 * sizeof(int)) / sizeof(int) - NumTable_LV1)  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxFileSize 	(NumDirect * SectorSize + MaxTableSize_LV1 * NumTable_LV1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileHeader</span> &#123;</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">...</span><br><span class="line">    <span class="type">int</span> dataSectors[NumDirect];		<span class="comment">// Disk sector numbers for each data </span></span><br><span class="line">					<span class="comment">// block in the file</span></span><br><span class="line">    <span class="type">int</span> dataSectors_LV1[NumTable_LV1];</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>紧接着，为了方便处理间接索引表，创建了一个数据结构IndexTable。其进包含两个功能，即从磁盘块中读取索引表，以及将索引表写回磁盘块。而索引表的大小（即条目数）则是来自于上面定义的宏常量<code>NumTableEntry</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IndexTable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">FetchFrom</span><span class="params">(<span class="type">int</span> sectorNumber)</span></span>;  <span class="comment">// Initialize file header from disk</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">WriteBack</span><span class="params">(<span class="type">int</span> sectorNumber)</span></span>;  <span class="comment">// Write modifications to file header</span></span><br><span class="line">    <span class="comment">//  back to disk</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> dataSectors[NumTableEntry];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IndexTable::FetchFrom</span><span class="params">(<span class="type">int</span> sectorNumber)</span> </span>&#123;</span><br><span class="line">    synchDisk-&gt;<span class="built_in">ReadSector</span>(sector, (<span class="type">char</span> *)<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IndexTable::WriteBack</span><span class="params">(<span class="type">int</span> sectorNumber)</span> </span>&#123;</span><br><span class="line">    synchDisk-&gt;<span class="built_in">WriteSector</span>(sector, (<span class="type">char</span> *)<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后修改FileHeader的<em>Allocate</em>方法以处理多级索引的磁盘块分配方式。分配成功的前提是文件大小不超过可分配的最大大小（即小于<code>MaxFileSize</code>）。</p>
<p>其实现方式，则是先判断文件所需的空间是否超过直接索引的最大大小，如果没有，则按照原先的方式处理。如果超出了，则需要进一步判断，是否有空间去存储一级索引表。</p>
<p>当上述条件全部满足时：</p>
<ol>
<li>先分配满全部的直接索引</li>
<li>超出部分则先分配一个磁盘空间给一级索引表，然后创建一级索引表结构indexTable，在索引表内填写数据之后写回磁盘</li>
<li>重复步骤2直至文件所需的大小</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * code/filesys/filehdr.cc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">bool</span></span></span><br><span class="line"><span class="function"><span class="title">FileHeader::Allocate</span><span class="params">(BitMap *freeMap, <span class="type">int</span> fileSize)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// 超出文件最大大小</span></span><br><span class="line">    <span class="keyword">if</span> (fileSize &gt; MaxFileSize)</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">  </span><br><span class="line">    numBytes = fileSize;</span><br><span class="line">    numSectors  = <span class="built_in">divRoundUp</span>(fileSize, SectorSize);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (numSectors &lt;= NumDirect) &#123;</span><br><span class="line">        <span class="keyword">if</span> (freeMap-&gt;<span class="built_in">NumClear</span>() &lt; numSectors)</span><br><span class="line">            <span class="keyword">return</span> FALSE;     <span class="comment">// not enough space</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numSectors; i++)</span><br><span class="line">            dataSectors[i] = freeMap-&gt;<span class="built_in">Find</span>();</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="type">int</span> restNeed = numSectors - NumDirect;</span><br><span class="line">       <span class="comment">// 计算还需要多少个一级索引</span></span><br><span class="line">       <span class="type">int</span> numSectors_LV1 = <span class="built_in">divRoundUp</span>(restNeed, NumTableEntry);</span><br><span class="line">       <span class="comment">// 一级索引表也需要占用磁盘块，因此还需要考虑索引表能否存储的下</span></span><br><span class="line">       <span class="keyword">if</span> (freeMap-&gt;<span class="built_in">NumClear</span>() &lt; numSectors + numSectors_LV1)</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 直接索引分配</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NumDirect; i++)</span><br><span class="line">            dataSectors[i] = freeMap-&gt;<span class="built_in">Find</span>();</span><br><span class="line">        <span class="comment">// 一级索引分配</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numSectors_LV1; i++) &#123;</span><br><span class="line">            dataSectors_LV1[i] = freeMap-&gt;<span class="built_in">Find</span>();</span><br><span class="line"></span><br><span class="line">            IndexTable * indexTable = <span class="keyword">new</span> IndexTable;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// i * NumTableEntry + j代表已在一级索引表中记录的磁盘块总数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; NumTableEntry &amp;&amp; (i * NumTableEntry + j) &lt; restNeed; j++) &#123;</span><br><span class="line">                indexTable-&gt;dataSectors[j] = freeMap-&gt;<span class="built_in">Find</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将索引表写回磁盘</span></span><br><span class="line">            indexTable-&gt;<span class="built_in">WriteBack</span>(dataSectors_LV1[i]);</span><br><span class="line">            <span class="keyword">delete</span> indexTable;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    crtTime = stats-&gt;totalTicks;</span><br><span class="line">    lastModTime = crtTime;</span><br><span class="line">    lastAccTime = crtTime;</span><br><span class="line">    parDirHeaderSector = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相应的，空间回收函数<em>Deallocate</em>也要做相应的改动。其具体实现与<em>Allocate</em>相反，因此不做赘述。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * code/filesys/filehdr.cc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> </span></span><br><span class="line"><span class="function"><span class="title">FileHeader::Deallocate</span><span class="params">(BitMap *freeMap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numSectors &lt;= NumDirect) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numSectors; i++) &#123;</span><br><span class="line">            <span class="built_in">ASSERT</span>(freeMap-&gt;<span class="built_in">Test</span>((<span class="type">int</span>) dataSectors[i]));  <span class="comment">// ought to be marked!</span></span><br><span class="line">            freeMap-&gt;<span class="built_in">Clear</span>((<span class="type">int</span>) dataSectors[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NumDirect; i++) &#123;</span><br><span class="line">            <span class="built_in">ASSERT</span>(freeMap-&gt;<span class="built_in">Test</span>((<span class="type">int</span>) dataSectors[i]));  <span class="comment">// ought to be marked!</span></span><br><span class="line">            freeMap-&gt;<span class="built_in">Clear</span>((<span class="type">int</span>) dataSectors[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> restNeed = numSectors - NumDirect;</span><br><span class="line">        <span class="type">int</span> numSectors_LV1 = <span class="built_in">divRoundUp</span>(restNeed, NumTableEntry);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numSectors_LV1; i++) &#123;</span><br><span class="line"></span><br><span class="line">            IndexTable * indexTable = <span class="keyword">new</span> IndexTable;</span><br><span class="line">            indexTable-&gt;<span class="built_in">FetchFrom</span>(dataSectors_LV1[i]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// i * NumTableEntry + j代表已在一级索引表中记录的磁盘块总数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; NumTableEntry &amp;&amp; (i * NumTableEntry + j) &lt; restNeed; j++) &#123;</span><br><span class="line">                <span class="built_in">ASSERT</span>(freeMap-&gt;<span class="built_in">Test</span>((<span class="type">int</span>) (indexTable-&gt;dataSectors[j])));  <span class="comment">// ought to be marked!</span></span><br><span class="line">                freeMap-&gt;<span class="built_in">Clear</span>((<span class="type">int</span>) (indexTable-&gt;dataSectors[j]));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">delete</span> indexTable;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 回收索引表的磁盘块</span></span><br><span class="line">            <span class="built_in">ASSERT</span>(freeMap-&gt;<span class="built_in">Test</span>((<span class="type">int</span>) dataSectors_LV1[i]));  <span class="comment">// ought to be marked!</span></span><br><span class="line">            freeMap-&gt;<span class="built_in">Clear</span>((<span class="type">int</span>) dataSectors_LV1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后还有一处重要的改动，就是对文本内字节偏移量与所属的磁盘块之间的转换函数<em>ByteToSector</em>的修改。其实现思路在于，如果是直接索引块，则直接返回。如果位于一级索引中，则先判断属于哪一个一级索引表（结果存储在sector_LV1中），然后从磁盘中读取该索引表，并进一步判断属于该索引表的哪个磁盘块，最终结果存储在finSector中，并返回finSector。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * code/filesys/filehdr.cc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">FileHeader::ByteToSector</span><span class="params">(<span class="type">int</span> offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (offset &lt; NumDirect * SectorSize) &#123;</span><br><span class="line">        <span class="keyword">return</span>(dataSectors[offset / SectorSize]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        offset -= NumDirect * SectorSize;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> sector_LV1 = offset / MaxTableSize_LV1;</span><br><span class="line">        offset = offset % MaxTableSize_LV1;</span><br><span class="line"></span><br><span class="line">        IndexTable * indexTable = <span class="keyword">new</span> IndexTable;</span><br><span class="line">        indexTable-&gt;<span class="built_in">FetchFrom</span>(dataSectors_LV1[sector_LV1]);</span><br><span class="line">        <span class="type">int</span> finSector = indexTable-&gt;dataSectors[offset / SectorSize];</span><br><span class="line">        <span class="keyword">delete</span> indexTable;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> finSector;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><p>修改<em>code&#x2F;filesys&#x2F;fstest.cc</em>中的FileSize宏，将创建的文件大小设为超出直接块能存储的最大大小（$20 \times  128 &#x3D; 2560 Bytes$），因此设为5000字节，其中ContentSize的值为10字节。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * code/filesys/fstest.cc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FileSize 	((int)(ContentSize * 500))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> </span></span><br><span class="line"><span class="function"><span class="title">FileWrite</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (!fileSystem-&gt;<span class="built_in">Create</span>(FileName, FileSize)) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>部分测试结果如下，可以看到文件正常完成读写操作。</p>
<img src="/2020/12/26/Nachos-Lab04-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20201220154733266.png" class="" title="扩展文件长度测试1">

<img src="/2020/12/26/Nachos-Lab04-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20201220154944341.png" class="" title="扩展文件长度测试2">

<h3 id="Exercise-4-实现多级目录"><a href="#Exercise-4-实现多级目录" class="headerlink" title="Exercise 4 实现多级目录"></a>Exercise 4 实现多级目录</h3><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>考虑到文件系统创建文件是通过传入文件名的方式来创建文件的，也就是说默认创建在根目录中。又考虑到在Exercise 2中的路径实现，为了不大量修改之前路径的实现代码，考虑<strong>修改文件系统的实现</strong>。也就是说，在文件系统中传入的name代表的含义不再是单纯的文件名，而是文件的绝对路径（或相对路径）。</p>
<h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><p>由于计划将<strong>文件系统中的name变量定义为绝对路径（DirectoryEntry中的name仍仅代表文件名，而非绝对路径）</strong>，因此需要实现一个路径解析函数<em>PathParse</em>。该函数对传入的绝对路径name进行解析，返回一个字符串数组以及数组长度nums。例如传入<code>name:=&quot;/root/123&quot;</code>，则之行结束以后获得字符串数组<code>&#123;[0] =&gt; &quot;root&quot;, [1] =&gt; &quot;123&quot;&#125;</code>，且nums为2。</p>
<p>可以注意到，<strong>这里的路径与之前Exercise 2执行结果中打印的路径有所差异</strong>。这是因为Exercise 2中路径检索是反向的，因此输出的需要倒序，但为了方便省略了倒序输出的步骤。所以真实路径为<code>/root/123</code>的文件123，将路径打印输出的结果为”123&#x2F;root&#x2F;“。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * code/filesys/filesys.cc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">char</span> ** <span class="title">FileSystem::PathParse</span><span class="params">(<span class="type">char</span> *name, <span class="type">int</span> *nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ** paths = <span class="keyword">new</span> <span class="type">char</span>*[MaxDirDeeps];  <span class="comment">// 为了使外部能访问</span></span><br><span class="line">    *nums = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> lens = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不以&#x27;/&#x27;开头，则意味文件创建在根目录</span></span><br><span class="line">    <span class="keyword">if</span> (name[<span class="number">0</span>] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (name[i] != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (name[i] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (lens &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    paths[*nums] = <span class="keyword">new</span> <span class="type">char</span>[lens + <span class="number">1</span>];</span><br><span class="line">                    <span class="built_in">strncpy</span>(paths[*nums], name + i - lens, lens);</span><br><span class="line">                    paths[*nums][lens] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                    lens = <span class="number">0</span>;</span><br><span class="line">                    (*nums)++;</span><br><span class="line">                    <span class="built_in">ASSERT</span>((*nums) &lt;= MaxDirDeeps);  <span class="comment">// 不能超过最大深度</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lens++;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        lens = <span class="built_in">strlen</span>(name);</span><br><span class="line">        i = lens;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理路径的最后部分，或处理直接根目录创建的文件</span></span><br><span class="line">    <span class="keyword">if</span> (lens &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        paths[*nums] = <span class="keyword">new</span> <span class="type">char</span>[lens + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strncpy</span>(paths[*nums], name + i - lens, lens);</span><br><span class="line">        paths[*nums][lens] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        (*nums)++;</span><br><span class="line">        <span class="built_in">ASSERT</span>((*nums) &lt;= MaxDirDeeps);  <span class="comment">// 不能超过最大深度</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> paths;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了方便在子目录创建文件，将文件系统中的创建文件的部分抽离出来，作为函数*_create*，用于在指定的文件夹中创建指定类型的文件。该函数会返回被成功创建的文件的文件头所在的磁盘块号。然后对于目录文件，除了创建文件头之外，<strong>还需要额外的创建一个Directory对象，并将其写回磁盘</strong>，才完成了目录文件的初始化。</p>
<p>（注：此处使用的目录添加函数<em>Directory::Add</em>为重载过的版本，支持指定文件类型这一属性。）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * code/filesys/filesys.cc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// 在指定的文件夹创建文件</span></span><br><span class="line"><span class="comment">// 成功则返回创建好的文件头磁盘块，否则返回-1</span></span><br><span class="line"><span class="comment">//----------------------------------------------------------------------</span></span><br><span class="line"><span class="type">int</span> FileSystem::_create(BitMap *freeMap, Directory *directory, <span class="type">int</span> dirSector, OpenFile * dirFile, <span class="type">char</span> *name, FileType fileType, <span class="type">int</span> initialSize) &#123;</span><br><span class="line">    <span class="type">bool</span> success;</span><br><span class="line">    FileHeader *hdr;</span><br><span class="line">    <span class="type">int</span> sector;</span><br><span class="line"></span><br><span class="line">    sector = freeMap-&gt;<span class="built_in">Find</span>();	<span class="comment">// find a sector to hold the file header</span></span><br><span class="line">    <span class="keyword">if</span> (sector == <span class="number">-1</span>)</span><br><span class="line">        success = FALSE;		<span class="comment">// no free block for file header</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!directory-&gt;<span class="built_in">Add</span>(name, sector, fileType))</span><br><span class="line">        success = FALSE;	<span class="comment">// no space in directory</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        hdr = <span class="keyword">new</span> FileHeader;</span><br><span class="line">        <span class="keyword">if</span> (!hdr-&gt;<span class="built_in">Allocate</span>(freeMap, initialSize))</span><br><span class="line">            success = FALSE;	<span class="comment">// no space on disk for data</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            success = TRUE;</span><br><span class="line">            hdr-&gt;<span class="built_in">setParDirHeaderSector</span>(dirSector);</span><br><span class="line">            <span class="comment">// everthing worked, flush all changes back to disk</span></span><br><span class="line">            hdr-&gt;<span class="built_in">WriteBack</span>(sector);</span><br><span class="line">            directory-&gt;<span class="built_in">WriteBack</span>(dirFile);</span><br><span class="line">            freeMap-&gt;<span class="built_in">WriteBack</span>(freeMapFile);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (fileType == F_DIRECTORY) &#123;</span><br><span class="line">                <span class="comment">// 对于目录文件，需要额外的创建一个Directory对象并将其写回磁盘</span></span><br><span class="line">                OpenFile *newDirFile = <span class="keyword">new</span> <span class="built_in">OpenFile</span>(sector);</span><br><span class="line">                Directory *newDir = <span class="keyword">new</span> <span class="built_in">Directory</span>(NumDirEntries);</span><br><span class="line">                newDir-&gt;<span class="built_in">WriteBack</span>(newDirFile);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">delete</span> newDirFile;</span><br><span class="line">                <span class="keyword">delete</span> newDir;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> hdr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (success)</span><br><span class="line">        <span class="keyword">return</span> sector;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由于出现了目录文件，因此在目录中新增一个函数<em>CheckDir</em>用于检查某一文件是否为目录文件。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * code/filesys/directory.cc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Directory::CheckDir</span><span class="params">(<span class="type">char</span> *name)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="built_in">FindIndex</span>(name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i != <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> table[i].fileType == F_DIRECTORY;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着在文件系统中实现目标目录查找函数<em>FileSystem::FindTargetDir</em>，该函数用于从路径中检索出文件最终被放置的文件夹。例如，路径为”&#x2F;root&#x2F;123&#x2F;aaa&#x2F;A”，文件为”A”，则该函数会返回文件夹”aaa”的文件头所处的磁盘块号。同时该函数也支持创建不存在文件夹。如果crt的值为<code>TRUE</code>，且文件夹”123”不存在，则该函数会同时创建文件夹”123”和”aaa”，并最终返回”aaa”的文件头所处的磁盘块号。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * code/filesys/filesys.cc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FileSystem::FindTargetDir</span><span class="params">(<span class="type">char</span> **paths, <span class="type">int</span> nums, <span class="type">bool</span> crt)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ASSERT</span>(nums &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> DirectorySector;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> sector = DirectorySector;</span><br><span class="line">        OpenFile * openFile;</span><br><span class="line">        Directory * directory;</span><br><span class="line">        BitMap * freeMap;</span><br><span class="line"></span><br><span class="line">        freeMap = <span class="keyword">new</span> <span class="built_in">BitMap</span>(NumSectors);</span><br><span class="line">        freeMap-&gt;<span class="built_in">FetchFrom</span>(freeMapFile);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后一个变量是文件名，因此需要nums - 1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sector == DirectorySector) &#123;</span><br><span class="line">                <span class="comment">// 此时位于根目录</span></span><br><span class="line">                openFile = directoryFile;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 位于某个子目录</span></span><br><span class="line">                openFile = <span class="keyword">new</span> <span class="built_in">OpenFile</span>(sector);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            directory = <span class="keyword">new</span> <span class="built_in">Directory</span>(NumDirEntries);</span><br><span class="line">            directory-&gt;<span class="built_in">FetchFrom</span>(openFile);</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> nextSector = directory-&gt;<span class="built_in">Find</span>(paths[i]);</span><br><span class="line">            <span class="keyword">if</span> (nextSector == <span class="number">-1</span>) &#123;  <span class="comment">// 此时不存在</span></span><br><span class="line">                <span class="keyword">if</span> (crt) &#123;</span><br><span class="line">                    <span class="comment">// 需要创建</span></span><br><span class="line">                    nextSector = _create(freeMap, directory, sector, openFile, paths[i], F_DIRECTORY, DirectoryFileSize);</span><br><span class="line">                    <span class="keyword">if</span> (nextSector == <span class="number">-1</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 创建失败</span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 不需要创建</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">ASSERT</span>(directory-&gt;<span class="built_in">CheckDir</span>(paths[i]));  <span class="comment">// 确保这是一个文件夹</span></span><br><span class="line">            sector = nextSector;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (openFile != directoryFile) &#123;</span><br><span class="line">                <span class="keyword">delete</span> openFile;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">delete</span> directory;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> freeMap;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sector;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时准备工作完成，开始修改文件系统中的文件操作代码，以适应绝对路径。</p>
<p>首先修改<em>FileSystem::Create</em>方法。该方法没有做特别多的变动，主要就是将原先直接在根目录上创建文件，修改为通过<em>FindTargetDir</em>先找到文件的父目录，然后在该目录内创建文件。然后<em>FileSystem::Open</em>和<em>FileSystem::Remove</em>也做类似的修改，即先找到最终的目录，然后在对文件做相应操作，具体实现这里就不再赘述。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * code/filesys/filesys.cc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">bool</span></span></span><br><span class="line"><span class="function"><span class="title">FileSystem::Create</span><span class="params">(<span class="type">char</span> *name, <span class="type">int</span> initialSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    OpenFile * openFile;</span><br><span class="line">    Directory *directory;</span><br><span class="line">    BitMap *freeMap;</span><br><span class="line">    <span class="type">int</span> sector;</span><br><span class="line">    <span class="type">bool</span> success;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DEBUG</span>(<span class="string">&#x27;f&#x27;</span>, <span class="string">&quot;Creating file %s, size %d\n&quot;</span>, name, initialSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析绝对路径name</span></span><br><span class="line">    <span class="type">int</span> pathsNums = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ** paths = <span class="built_in">PathParse</span>(name, &amp;pathsNums);</span><br><span class="line">    <span class="comment">// 获取最终的文件夹磁盘块号</span></span><br><span class="line">    <span class="comment">// 由于是创建，所以允许创建路径上的文件夹</span></span><br><span class="line">    sector = <span class="built_in">FindTargetDir</span>(paths, pathsNums, TRUE);</span><br><span class="line">    <span class="keyword">if</span> (sector == <span class="number">-1</span>) &#123;</span><br><span class="line">        success = FALSE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sector == DirectorySector) &#123;</span><br><span class="line">            openFile = directoryFile;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            openFile = <span class="keyword">new</span> <span class="built_in">OpenFile</span>(sector);</span><br><span class="line">        &#125;</span><br><span class="line">        directory = <span class="keyword">new</span> <span class="built_in">Directory</span>(NumDirEntries);</span><br><span class="line">        directory-&gt;<span class="built_in">FetchFrom</span>(openFile);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (directory-&gt;<span class="built_in">Find</span>(paths[pathsNums - <span class="number">1</span>]) != <span class="number">-1</span>)</span><br><span class="line">            success = FALSE;			<span class="comment">// file is already in directory</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            freeMap = <span class="keyword">new</span> <span class="built_in">BitMap</span>(NumSectors);</span><br><span class="line">            freeMap-&gt;<span class="built_in">FetchFrom</span>(freeMapFile);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (_create(freeMap, directory, sector, openFile, paths[pathsNums - <span class="number">1</span>], F_NORMAL, initialSize) != <span class="number">-1</span>) &#123;</span><br><span class="line">                success = TRUE;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                success = FALSE;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">delete</span> freeMap;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pathsNums; i++) &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] (paths[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] paths;</span><br><span class="line">    <span class="keyword">if</span> (openFile != directoryFile)</span><br><span class="line">        <span class="keyword">delete</span> openFile;</span><br><span class="line">    <span class="keyword">delete</span> directory;</span><br><span class="line">    <span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h4><p>修改测试函数<em>PerformanceTest</em>，分别对文件系统的进行文件的创建操作、对多级目录下的文件进行读写操作、和对这些文件的移除操作。</p>
<p>测试结果如下：其测试中分别创建了”&#x2F;123”，”&#x2F;usr&#x2F;A”，”&#x2F;usr&#x2F;aaa&#x2F;C”，”&#x2F;usr&#x2F;aaa&#x2F;B”四个文件；然后对文件”&#x2F;usr&#x2F;aaa&#x2F;B”进行读写操作测试；接着列出各个文件夹下的文件，其中首部的数字”0”代表普通文件、”1”代表目录文件；最后将这些文件进行移除。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">root@02487b68b87e:/nachos/nachos-3.4/code/filesys<span class="comment"># ./nachos -f -t</span></span><br><span class="line">Starting file system performance <span class="built_in">test</span>:</span><br><span class="line">Perf <span class="built_in">test</span>: create /123</span><br><span class="line">Perf <span class="built_in">test</span>: create /usr/A</span><br><span class="line">Perf <span class="built_in">test</span>: create /usr/aaa/C</span><br><span class="line">Perf <span class="built_in">test</span>: create /usr/aaa/B</span><br><span class="line">Sequential write of 100 byte file, <span class="keyword">in</span> 10 byte chunks</span><br><span class="line">Sequential <span class="built_in">read</span> of 100 byte file, <span class="keyword">in</span> 10 byte chunks</span><br><span class="line">List Directory =&gt; / </span><br><span class="line">0 123</span><br><span class="line"> 1 usr</span><br><span class="line"> List Directory =&gt; /usr </span><br><span class="line">0 A</span><br><span class="line"> 1 aaa</span><br><span class="line"> List Directory =&gt; /usr/aaa </span><br><span class="line">0 C</span><br><span class="line"> 0 B</span><br><span class="line"> Perf <span class="built_in">test</span>: remove /usr/aaa/B</span><br><span class="line">Perf <span class="built_in">test</span>: remove /123</span><br><span class="line">Perf <span class="built_in">test</span>: remove /usr/A</span><br><span class="line">Perf <span class="built_in">test</span>: remove /usr/aaa/C</span><br><span class="line">No threads ready or runnable, and no pending interrupts.</span><br><span class="line">Assuming the program completed.</span><br><span class="line">Machine halting!</span><br><span class="line"></span><br><span class="line">Ticks: total 775540, idle 764500, system 11040, user 0</span><br><span class="line">Disk I/O: reads 138, writes 55</span><br><span class="line">Console I/O: reads 0, writes 0</span><br><span class="line">Paging: faults 0</span><br><span class="line">Network I/O: packets received 0, sent 0</span><br><span class="line"></span><br><span class="line">Cleaning up...</span><br></pre></td></tr></table></figure>

<h3 id="Exercise-5-动态调整文件长度"><a href="#Exercise-5-动态调整文件长度" class="headerlink" title="Exercise 5 动态调整文件长度"></a>Exercise 5 动态调整文件长度</h3><blockquote>
<p>对文件的创建操作和写入操作进行适当修改，以使其符合实习要求。</p>
</blockquote>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>动态调整文件长度也就意味着，在对文件进行内容写入时，如果剩余空间不足，则动态申请新的磁盘块来存储写入的数据。</p>
<h4 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h4><p>首先为了满足要求，实现一个动态申请空间的函数<em>Extend</em>，该函数的实现方式与<em>FileHeader::Allocate</em>类似。但由于是申请额外的空间，需要做很多处理，如继续之前的情况分配直接索引块，或是继续分配一张一级索引表中未使用的空间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * code/filesys/filehdr.cc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">FileHeader::Extend</span><span class="params">(BitMap *freeMap, <span class="type">int</span> Size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numBytes + Size &gt; MaxFileSize)</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算还需多少个磁盘块</span></span><br><span class="line">    <span class="type">int</span> totalSectors = <span class="built_in">divRoundUp</span>(Size + numBytes, SectorSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先处理直接索引</span></span><br><span class="line">    <span class="keyword">if</span> (totalSectors &lt;= NumDirect) &#123;</span><br><span class="line">        <span class="keyword">if</span> (freeMap-&gt;<span class="built_in">NumClear</span>() &lt; totalSectors - numSectors)</span><br><span class="line">            <span class="keyword">return</span> FALSE;		<span class="comment">// not enough space</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = numSectors; i &lt; totalSectors; i++) &#123;</span><br><span class="line">            dataSectors[i] = freeMap-&gt;<span class="built_in">Find</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> restNeed = totalSectors - NumDirect;</span><br><span class="line">        <span class="comment">// 计算共需要多少个一级索引</span></span><br><span class="line">        <span class="type">int</span> numSectors_LV1 = <span class="built_in">divRoundUp</span>(restNeed, NumTableEntry);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一级索引表也需要占用磁盘块，因此还需要考虑索引表能否存储的下</span></span><br><span class="line">        <span class="type">int</span> add_on = totalSectors - numSectors;</span><br><span class="line">        <span class="keyword">if</span> (numSectors &gt; NumDirect) &#123;</span><br><span class="line">            add_on += numSectors_LV1 - <span class="built_in">divRoundUp</span>(numSectors - NumDirect, NumTableEntry);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (freeMap-&gt;<span class="built_in">NumClear</span>() &lt; add_on)</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 直接索引分配，如果原先大小已经使用了一级索引，则该循环无法执行</span></span><br><span class="line">        <span class="keyword">for</span> (; numSectors &lt; NumDirect; numSectors++)</span><br><span class="line">            dataSectors[numSectors] = freeMap-&gt;<span class="built_in">Find</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分别代表开始写入的一级索引表内部偏移，以及位于哪张索引表</span></span><br><span class="line">        <span class="type">int</span> innerOffset_LV1 = (numSectors - NumDirect) % NumTableEntry;</span><br><span class="line">        <span class="type">int</span> Offset_LV1 = (numSectors - NumDirect) / NumTableEntry;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一级索引分配</span></span><br><span class="line">        <span class="keyword">if</span> (innerOffset_LV1 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            IndexTable * indexTable = <span class="keyword">new</span> IndexTable;</span><br><span class="line">            <span class="comment">// 内部偏移大于0，意味着最后一张一级索引表还未填写完</span></span><br><span class="line">            indexTable-&gt;<span class="built_in">FetchFrom</span>(dataSectors_LV1[Offset_LV1]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = innerOffset_LV1; j &lt; NumTableEntry &amp;&amp; (Offset_LV1 * NumTableEntry + j) &lt; restNeed; j++) &#123;</span><br><span class="line">                indexTable-&gt;dataSectors[j] = freeMap-&gt;<span class="built_in">Find</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将索引表写回磁盘</span></span><br><span class="line">            indexTable-&gt;<span class="built_in">WriteBack</span>(dataSectors_LV1[Offset_LV1]);</span><br><span class="line">            <span class="keyword">delete</span> indexTable;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = Offset_LV1 + <span class="number">1</span>; i &lt; numSectors_LV1; i++) &#123;</span><br><span class="line">            dataSectors_LV1[i] = freeMap-&gt;<span class="built_in">Find</span>();</span><br><span class="line"></span><br><span class="line">            IndexTable * indexTable = <span class="keyword">new</span> IndexTable;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// i * NumTableEntry + j代表已在一级索引表中记录的磁盘块总数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; NumTableEntry &amp;&amp; (i * NumTableEntry + j) &lt; restNeed; j++) &#123;</span><br><span class="line">                indexTable-&gt;dataSectors[j] = freeMap-&gt;<span class="built_in">Find</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将索引表写回磁盘</span></span><br><span class="line">            indexTable-&gt;<span class="built_in">WriteBack</span>(dataSectors_LV1[i]);</span><br><span class="line">            <span class="keyword">delete</span> indexTable;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    numBytes += Size;</span><br><span class="line">    numSectors = totalSectors;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，由于申请空间需要调用freeMap，而该位图文件是文件系统的私有成员，因此还应当在FileSystem中实现一个拓展的封装。</p>
<p>由于考虑到该函数是被OpenFile调用，而OpenFile内部维护一个文件头指针<code>FileHeader * hdr</code>，考虑到需要使两者数据一致，因此OpenFile调用完该函数之后，需要重新将磁盘上的文件头读取到内存中。</p>
<p>因为仅传入一个磁盘块号，那么对该文件头的改动仅会影响磁盘上的数据，而已经读入内存的数据不会发生变化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * code/filesys/filesys.cc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">FileSystem::FileExtend</span><span class="params">(<span class="type">int</span> sector, <span class="type">int</span> Size)</span> </span>&#123;</span><br><span class="line">    BitMap *freeMap;</span><br><span class="line">    FileHeader *hdr;</span><br><span class="line">    </span><br><span class="line">    freeMap = <span class="keyword">new</span> <span class="built_in">BitMap</span>(NumSectors);</span><br><span class="line">    freeMap-&gt;<span class="built_in">FetchFrom</span>(freeMapFile);</span><br><span class="line"></span><br><span class="line">    hdr = <span class="keyword">new</span> FileHeader;</span><br><span class="line">    hdr-&gt;<span class="built_in">FetchFrom</span>(sector);</span><br><span class="line">    hdr-&gt;<span class="built_in">Extend</span>(freeMap, Size);</span><br><span class="line">    hdr-&gt;<span class="built_in">WriteBack</span>(sector);</span><br><span class="line">  </span><br><span class="line">  	freeMap-&gt;<span class="built_in">WriteBack</span>(freeMapFile);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> freeMap;</span><br><span class="line">    <span class="keyword">delete</span> hdr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此为了方便文件头的重读取或者写回，在OpenFile中额外维护一个文件头磁盘块号hdrSector。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * code/filesys/openfile.h</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OpenFile</span> &#123;</span><br><span class="line">...    </span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">...</span><br><span class="line">    <span class="type">int</span> hdrSector;  <span class="comment">// Header所处的磁盘块</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * code/filesys/openfile.cc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">OpenFile::<span class="built_in">OpenFile</span>(<span class="type">int</span> sector)</span><br><span class="line">&#123; </span><br><span class="line">...</span><br><span class="line">    hdrSector = sector;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文件创建操作可以不做修改，因为<em>FileHeader::Allocate</em>函数可以通过传入参数fileSize为0，而使得文件在创建时仅有FileHeader而不包含任何已分配的数据块。</p>
<p>再看文件写操作，有两个<em>OpenFile::Write</em>和<em>OpenFile::WriteAt</em>。查看代码可知<em>OpenFile::Write</em>是对<em>OpenFile::WriteAt</em>的一个封装，因此动态申请调用发生在<em>OpenFile::WriteAt</em>中。</p>
<p>这里主要做了两处改动：</p>
<ol>
<li>由于支持了动态拓展，那么也就允许在文件末尾后一个字节开始写入，即允许<code>position == fileLength</code></li>
<li>对于写入字节长度超出文件大小时，调用拓展函数申请新的空间。但如果申请失败，则按照原有规则处理。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * code/filesys/openfile.cc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">OpenFile::WriteAt</span><span class="params">(<span class="type">char</span> *from, <span class="type">int</span> numBytes, <span class="type">int</span> position)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> ((numBytes &lt;= <span class="number">0</span>) || (position &gt; fileLength))</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;				<span class="comment">// check request</span></span><br><span class="line">    <span class="keyword">if</span> ((position + numBytes) &gt; fileLength) &#123;</span><br><span class="line">        <span class="type">int</span> need = position + numBytes - fileLength;</span><br><span class="line">        <span class="keyword">if</span> (fileSystem-&gt;<span class="built_in">FileExtend</span>(hdrSector, need)) &#123;</span><br><span class="line">            <span class="comment">// 额外空间申请成功，更新文件头</span></span><br><span class="line">            hdr-&gt;<span class="built_in">FetchFrom</span>(hdrSector);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Extend %d Bytes Success!\n&quot;</span>, need);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (position == fileLength) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            numBytes = fileLength - position;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="测试-3"><a href="#测试-3" class="headerlink" title="测试"></a>测试</h4><p>由于实现了文件的动态拓展，因此在测试时将文件的初始大小设为0。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * code/filesys/fstest.cc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FileSize 	((int)(ContentSize * 10))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> </span></span><br><span class="line"><span class="function"><span class="title">FileWrite</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (!fileSystem-&gt;<span class="built_in">Create</span>(FileName, <span class="number">0</span>)) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">root@02487b68b87e:/nachos/nachos-3.4/code/filesys<span class="comment"># ./nachos -f -t</span></span><br><span class="line">Starting file system performance <span class="built_in">test</span>:</span><br><span class="line">Ticks: total 82530, idle 82090, system 440, user 0</span><br><span class="line">Disk I/O: reads 3, writes 5</span><br><span class="line">Console I/O: reads 0, writes 0</span><br><span class="line">Paging: faults 0</span><br><span class="line">Network I/O: packets received 0, sent 0</span><br><span class="line">Sequential write of 100 byte file, <span class="keyword">in</span> 10 byte chunks</span><br><span class="line">Extend 10 Bytes Success!</span><br><span class="line">Extend 10 Bytes Success!</span><br><span class="line">Extend 10 Bytes Success!</span><br><span class="line">Extend 10 Bytes Success!</span><br><span class="line">Extend 10 Bytes Success!</span><br><span class="line">Extend 10 Bytes Success!</span><br><span class="line">Extend 10 Bytes Success!</span><br><span class="line">Extend 10 Bytes Success!</span><br><span class="line">Extend 10 Bytes Success!</span><br><span class="line">Extend 10 Bytes Success!</span><br><span class="line">Sequential <span class="built_in">read</span> of 100 byte file, <span class="keyword">in</span> 10 byte chunks</span><br><span class="line">Ticks: total 514530, idle 508340, system 6190, user 0</span><br><span class="line">Disk I/O: reads 68, writes 42</span><br><span class="line">Console I/O: reads 0, writes 0</span><br><span class="line">Paging: faults 0</span><br><span class="line">Network I/O: packets received 0, sent 0</span><br><span class="line">No threads ready or runnable, and no pending interrupts.</span><br><span class="line">Assuming the program completed.</span><br><span class="line">Machine halting!</span><br><span class="line"></span><br><span class="line">Ticks: total 514540, idle 508350, system 6190, user 0</span><br><span class="line">Disk I/O: reads 68, writes 42</span><br><span class="line">Console I/O: reads 0, writes 0</span><br><span class="line">Paging: faults 0</span><br><span class="line">Network I/O: packets received 0, sent 0</span><br><span class="line"></span><br><span class="line">Cleaning up...</span><br></pre></td></tr></table></figure>

<h2 id="文件访问的同步与互斥"><a href="#文件访问的同步与互斥" class="headerlink" title="文件访问的同步与互斥"></a>文件访问的同步与互斥</h2><h3 id="Exercise-6-源代码阅读"><a href="#Exercise-6-源代码阅读" class="headerlink" title="Exercise 6 源代码阅读"></a>Exercise 6 源代码阅读</h3><blockquote>
<ol>
<li>阅读Nachos源代码中与异步磁盘相关的代码，理解Nachos系统中异步访问模拟磁盘的工作原理。filesys&#x2F;synchdisk.h和filesys&#x2F;synchdisk.cc</li>
<li>利用异步访问模拟磁盘的工作原理，在Class Console的基础上，实现Class SynchConsole。</li>
</ol>
</blockquote>
<h4 id="源码阅读"><a href="#源码阅读" class="headerlink" title="源码阅读"></a>源码阅读</h4><p><em>filesys&#x2F;synchdisk.h和filesys&#x2F;synchdisk.cc</em>：同步磁盘的实现本身比较简单，即在Disk类的基础之上添加了同步机制。SynchDisk类中共利用了两种同步机制，锁和信号量。锁的作用主要是保护读写请求的原子性（即保证每次仅有一个线程在进行磁盘I&#x2F;O）。而信号量则主要用在中断处理中，用于保证中断的同步（即确保磁盘一次仅处理一个操作）。</p>
<h4 id="SynchConsole思路"><a href="#SynchConsole思路" class="headerlink" title="SynchConsole思路"></a>SynchConsole思路</h4><p>首先简单分析一个Console的实现。Console是一个终端I&#x2F;O的模拟类，它由读写文件类模拟输入和输出。它的操作也主要为<code>PutChar</code>、<code>GetChar</code>、<code>WriteDone</code>。因此参考SynchDisk的方式实现SynchConsole的思路就是读写部分操作的互斥以及中断的互斥。</p>
<h4 id="SynchConsole实现"><a href="#SynchConsole实现" class="headerlink" title="SynchConsole实现"></a>SynchConsole实现</h4><p>首先在*code&#x2F;machine&#x2F;*目录下创建两个文件，分别是synchconsole.h和synchconsole.cc</p>
<p>为了使创建的文件生效，需要修改<em>code&#x2F;Makefile.common</em>文件，改动部分如下图所示。考虑到仅有用户程序需要用到Console，因此仅将其加入到<strong>USERPROG</strong>中。</p>
<img src="/2020/12/26/Nachos-Lab04-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20201224172809826.png" class="" title="Makefile.common">

<p><code>class Synchconsole</code>主要满足的策略是读和读的互斥，以及写与写的互斥。由于Console的读写分别对应的是不同的文件，因此重要的是保护模拟输入的文件的互斥，以及模拟输出的文件的互斥。</p>
<p>大致实现上与SynchDisk没有什么区别。重要的实现部分如下，需要注意的是<strong>对于读而言是先确保可读再进行读操作，因此先对进行<em>P</em>操作再执行<em>Getchar</em></strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * code/machine/synchconsole.cc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SynchConsole::PutChar</span><span class="params">(<span class="type">char</span> ch)</span> </span>&#123;</span><br><span class="line">    writeLock-&gt;<span class="built_in">Acquire</span>();</span><br><span class="line">    console-&gt;<span class="built_in">PutChar</span>(ch);</span><br><span class="line">    writeDone-&gt;<span class="built_in">P</span>();</span><br><span class="line">    writeLock-&gt;<span class="built_in">Release</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SynchConsole::GetChar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    readLock-&gt;<span class="built_in">Acquire</span>();</span><br><span class="line">    readAvail-&gt;<span class="built_in">P</span>();</span><br><span class="line">    console-&gt;<span class="built_in">GetChar</span>();</span><br><span class="line">    readLock-&gt;<span class="built_in">Release</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Exercise-7-实现文件系统的同步互斥访问机制，达到如下效果"><a href="#Exercise-7-实现文件系统的同步互斥访问机制，达到如下效果" class="headerlink" title="Exercise 7 实现文件系统的同步互斥访问机制，达到如下效果"></a>Exercise 7 实现文件系统的同步互斥访问机制，达到如下效果</h3><blockquote>
<ol>
<li><p>一个文件可以同时被多个线程访问。且每个线程独自打开文件，独自拥有一个当前文件访问位置，彼此间不会互相干扰。</p>
</li>
<li><p>所有对文件系统的操作必须是原子操作和序列化的。例如，当一个线程正在修改一个文件，而另一个线程正在读取该文件的内容时，读线程要么读出修改过的文件，要么读出原来的文件，不存在不可预计的中间状态。</p>
</li>
<li><p>当某一线程欲删除一个文件，而另外一些线程正在访问该文件时，需保证所有线程关闭了这个文件，该文件才被删除。也就是说，只要还有一个线程打开了这个文件，该文件就不能真正地被删除。</p>
</li>
</ol>
</blockquote>
<h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><ol>
<li>这一点的实现可以通过不同线程各自创建一个OpenFile对象来处理。即每个线程都拥有基于同一磁盘块号创建的OpenFIie对象，那么它们各自内部都维护了互不干扰的访问位置。这一点由文件系统的<em>Open</em>操作来保证。</li>
<li>这一个要求的主要是为了避免，有线程正在对文件写时，另一个程序执行读，但是由于其不知道有程序正在写而导致读出来的数据可能是部分被修改的。因此要保证的就是要么读取修改结束后的，要么读取修改开始前的，而不是读取正在被修改的。</li>
<li>对文件实现一个全局的引用计数，每当有新的线程访问该文件，就对该文件的引用计数+1，而线程访问结束的时候就将该值-1。如果有线程尝试删除文件，则会根据引用计数的值是否为0来判断文件能否被立即删除。</li>
</ol>
<h4 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h4><p>对于<strong>第1点</strong>，检查文件系统的<em>Open</em>操作的实现，可以发现，每次打开文件会先进行<code>new OpenFile(sector)</code>操作，再将新创建好的OpenFile对象返回。因此不需要做额外的改动。</p>
<p>对于<strong>第2点</strong>，为了保证某个磁盘块正在被写的时候不会被读，考虑在SynchDisk中，维护一个信号量数组sectorSemaphore，该数组用于确保每个磁盘块的读写互斥。并提供如下操作，允许对某个磁盘块进行<em>P</em>操作或者<em>V</em>操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * code/filesys/synchdisk.cc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SynchDisk::PSector</span><span class="params">(<span class="type">int</span> sector)</span> </span>&#123;</span><br><span class="line">    sectorSemaphore[sector]-&gt;<span class="built_in">P</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SynchDisk::VSevtor</span><span class="params">(<span class="type">int</span> sector)</span> </span>&#123;</span><br><span class="line">    sectorSemaphore[sector]-&gt;<span class="built_in">V</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后对文件的读写操作进行修改。在读或写之前先获取文件头磁盘块的访问权，然后更新文件头，操作结束之后，先将可能有改动的文件头写回，再释放该磁盘块的访问。之所以仅对文件头的磁盘块做互斥访问限制，主要是为了简便。这样只有先拿到文件头的访问权，才能对数据作修改。写操作可能会修改文件头数据索引，而读之前也要考虑是否要更新，文件头的更新操作是必要的。因此也就没必要再单独对读写访问的各个磁盘块上锁。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * code/filesys/openfile.cc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">OpenFile::ReadAt</span><span class="params">(<span class="type">char</span> *into, <span class="type">int</span> numBytes, <span class="type">int</span> position)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 读之前先更新文件头</span></span><br><span class="line">    synchDisk-&gt;<span class="built_in">PSector</span>(hdrSector);</span><br><span class="line">    hdr-&gt;<span class="built_in">FetchFrom</span>(hdrSector);</span><br><span class="line">...</span><br><span class="line">    <span class="comment">// 读完之后写回一次文件头</span></span><br><span class="line">    hdr-&gt;<span class="built_in">WriteBack</span>(hdrSector);</span><br><span class="line">    synchDisk-&gt;<span class="built_in">VSector</span>(hdrSector);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">OpenFile::WriteAt</span><span class="params">(<span class="type">char</span> *from, <span class="type">int</span> numBytes, <span class="type">int</span> position)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 写之前先更新文件头</span></span><br><span class="line">    synchDisk-&gt;<span class="built_in">PSector</span>(hdrSector);</span><br><span class="line">    hdr-&gt;<span class="built_in">FetchFrom</span>(hdrSector);</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (!firstAligned) &#123;</span><br><span class="line">        synchDisk-&gt;<span class="built_in">VSector</span>(hdrSector);</span><br><span class="line">        <span class="built_in">ReadAt</span>(buf, SectorSize, firstSector * SectorSize);</span><br><span class="line">        synchDisk-&gt;<span class="built_in">PSector</span>(hdrSector);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!lastAligned &amp;&amp; ((firstSector != lastSector) || firstAligned)) &#123;</span><br><span class="line">        synchDisk-&gt;<span class="built_in">VSector</span>(hdrSector);</span><br><span class="line">        <span class="built_in">ReadAt</span>(&amp;buf[(lastSector - firstSector) * SectorSize],</span><br><span class="line">               SectorSize, lastSector * SectorSize);</span><br><span class="line">        synchDisk-&gt;<span class="built_in">PSector</span>(hdrSector);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">    <span class="comment">// 写完之后写回一次文件头</span></span><br><span class="line">    hdr-&gt;<span class="built_in">WriteBack</span>(hdrSector);</span><br><span class="line">    synchDisk-&gt;<span class="built_in">VSector</span>(hdrSector);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于<strong>第3点</strong>，由于文件系统的Remove操作，最终会调用目录中的Remove方法，来实现文件的删除。因此文件引用计数则放置在目录项中，如果要对文件进行删除，则需要判断引用计数是否为0；如果引用计数不为0，则删除失败。</p>
<p>将引用计数放在目录项中，作为文件的一个属性。然后新增根据文件头的磁盘块号对文件计数+1以及计数-1的操作。同时目录类还支持检查文件的引用计数是否为0的<em>CheckRefClear</em>操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * code/filesys/directory.h</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DirectoryEntry</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">...    </span><br><span class="line">    <span class="type">int</span> refCount;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * code/filesys/directory.cc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">bool</span></span></span><br><span class="line"><span class="function"><span class="title">Directory::Add</span><span class="params">(<span class="type">char</span> *name, <span class="type">int</span> newSector, FileType fileType)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">            table[i].refCount = <span class="number">0</span>;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Directory::PlusRef</span><span class="params">(<span class="type">int</span> sector)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; tableSize; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (table[i].inUse &amp;&amp; table[i].sector == sector) &#123;</span><br><span class="line">            table[i].refCount++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Directory::NegaRef</span><span class="params">(<span class="type">int</span> sector)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; tableSize; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (table[i].inUse &amp;&amp; table[i].sector == sector) &#123;</span><br><span class="line">            table[i].refCount--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Directory::CheckRefClear</span><span class="params">(<span class="type">int</span> sector)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; tableSize; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (table[i].inUse &amp;&amp; table[i].sector == sector) &#123;</span><br><span class="line">            <span class="keyword">return</span> table[i].refCount == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将引用计数的修改操作，在文件系统中做一个该接口的封装，方便OpenFile使用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * code/filesys/directory.cc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileSystem</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PlusRef</span><span class="params">(<span class="type">int</span> sector, <span class="type">int</span> parSector)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">NegaRef</span><span class="params">(<span class="type">int</span> sector, <span class="type">int</span> parSector)</span></span>;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后修改OpenFile类的构造函数以及析构函数，这样当文件被打开时，会增加引用计数，而当文件被关闭时会减少引用计数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * code/filesys/openfile.cc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">OpenFile::<span class="built_in">OpenFile</span>(<span class="type">int</span> sector)</span><br><span class="line">&#123; </span><br><span class="line">...</span><br><span class="line">    fileSystem-&gt;<span class="built_in">PlusRef</span>(sector, hdr-&gt;<span class="built_in">getParDirHeaderSector</span>());</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">OpenFile::~<span class="built_in">OpenFile</span>()</span><br><span class="line">&#123;</span><br><span class="line">    fileSystem-&gt;<span class="built_in">NegaRef</span>(hdrSector, hdr-&gt;<span class="built_in">getParDirHeaderSector</span>());</span><br><span class="line">    <span class="keyword">delete</span> hdr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后修改文件系统的Remove方法，当文件不存在或者引用计数不为0时，文件删除失败。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * code/filesys/filesys.cc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (sector == <span class="number">-1</span> || !directory-&gt;<span class="built_in">CheckRefClear</span>(sector)) &#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="测试-4"><a href="#测试-4" class="headerlink" title="测试"></a>测试</h4><p>为了方便测试，在OpenFile中新增一个<em>getPos</em>方法，来查看文件的seekPosition的值。</p>
<p>首先测试第1点，两个线程同时读文件，结果如下。可以看到两个线程同时读取同一个文件，各自维护了一个文件位置标志。</p>
<img src="/2020/12/26/Nachos-Lab04-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20201226123644740.png" class="" title="第1点结果">

<p>然后测试第2点，可以看到读写交替进行。</p>
<img src="/2020/12/26/Nachos-Lab04-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20201226124721667.png" class="" title="第2点结果">

<p>最后测试第3点，当文件正在写的时候，文件删除失败了；直到写结束的时候，再尝试删除，则成功。</p>
<img src="/2020/12/26/Nachos-Lab04-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20201226130757395.png" class="" title="第3点结果">



<h2 id="Challenges题目"><a href="#Challenges题目" class="headerlink" title="Challenges题目"></a>Challenges题目</h2><h3 id="Challenge-1-性能优化"><a href="#Challenge-1-性能优化" class="headerlink" title="Challenge 1  性能优化"></a>Challenge 1  性能优化</h3><blockquote>
<ol>
<li><p>例如，为了优化寻道时间和旋转延迟时间，可以将同一文件的数据块放置在磁盘同一磁道上</p>
</li>
<li><p>使用cache机制减少磁盘访问次数，例如延迟写和预读取。</p>
</li>
</ol>
</blockquote>
<h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><h4 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h4><h3 id="Challenge-2-实现pipe机制"><a href="#Challenge-2-实现pipe机制" class="headerlink" title="Challenge 2 实现pipe机制"></a>Challenge 2 实现pipe机制</h3><blockquote>
<p>重定向openfile的输入输出方式，使得前一进程从控制台读入数据并输出至管道，后一进程从管道读入数据并输出至控制台。</p>
</blockquote>
<h4 id="实现-6"><a href="#实现-6" class="headerlink" title="实现"></a>实现</h4><p>在文件系统中新增两个宏，用于标示pipe文件的固定磁盘位置，以及其最大文件大小。并在文件系统的构造函数中对其初始化，pipe文件的初始值为0。仅维护pipe文件的文件头磁盘块，而具体文件则不在文件系统中维护。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PipeSector          2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PipeFileSize        0</span></span><br></pre></td></tr></table></figure>

<p>然后在OpenFile类中新增一个功能<em>ReadAll</em>用于一次性读取文件的所有字节。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * code/filesys/openfile.cc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">OpenFile::ReadAll</span><span class="params">(<span class="type">char</span> *into)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">ReadAt</span>(into, hdr-&gt;<span class="built_in">FileLength</span>(), seekPosition);</span><br><span class="line">    seekPosition += result;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据之前的设计，Pipe文件的大小会动态增涨。因此分别实现Pipe文件的读写操作函数。对于读操作，不仅会一次性读取Pipe中的所有字节，而且会清空Pipe，即读完之后Pipe的大小为0。对于写操作，由于支持动态增长，以及读写操作都会更新文件头，因此仅需要调用<em>Write</em>方法即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * code/filesys/filesys.cc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FileSystem::ReadPipe</span><span class="params">(<span class="type">char</span> *data)</span> </span>&#123;</span><br><span class="line">    OpenFile* openFile = <span class="keyword">new</span> <span class="built_in">OpenFile</span>(PipeSector);</span><br><span class="line">    <span class="type">int</span> result = openFile-&gt;<span class="built_in">ReadAll</span>(data);</span><br><span class="line"></span><br><span class="line">    BitMap *freeMap = <span class="keyword">new</span> <span class="built_in">BitMap</span>(NumSectors);</span><br><span class="line">    freeMap-&gt;<span class="built_in">FetchFrom</span>(freeMapFile);</span><br><span class="line"></span><br><span class="line">    FileHeader *pipeHdr = <span class="keyword">new</span> FileHeader;</span><br><span class="line">    pipeHdr-&gt;<span class="built_in">FetchFrom</span>(PipeSector);</span><br><span class="line">    pipeHdr-&gt;<span class="built_in">Deallocate</span>(freeMap);</span><br><span class="line">    pipeHdr-&gt;<span class="built_in">Allocate</span>(freeMap, <span class="number">0</span>);</span><br><span class="line">    pipeHdr-&gt;<span class="built_in">WriteBack</span>(PipeSector);</span><br><span class="line"></span><br><span class="line">    freeMap-&gt;<span class="built_in">WriteBack</span>(freeMapFile);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FileSystem::WritePipe</span><span class="params">(<span class="type">char</span> *data)</span> </span>&#123;</span><br><span class="line">    OpenFile* openFile = <span class="keyword">new</span> <span class="built_in">OpenFile</span>(PipeSector);</span><br><span class="line">    <span class="type">int</span> result = openFile-&gt;<span class="built_in">Write</span>(data, <span class="built_in">strlen</span>(data));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="测试-5"><a href="#测试-5" class="headerlink" title="测试"></a>测试</h4><p>设计测试函数如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PipeInTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread 1 put data in pipe\n&quot;</span>);</span><br><span class="line">    <span class="type">char</span> in[FileSize + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, in);</span><br><span class="line">    fileSystem-&gt;<span class="built_in">WritePipe</span>(in);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PipeOutTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread 2 get data from pipe\n&quot;</span>);</span><br><span class="line">    <span class="type">char</span> out[FileSize + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    fileSystem-&gt;<span class="built_in">ReadPipe</span>(out);</span><br><span class="line">    <span class="built_in">prinft</span>(<span class="string">&quot;Output: %s&quot;</span>, out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分别调用执行，结果如下：</p>
<img src="/2020/12/26/Nachos-Lab04-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20201226160701579.png" class="" title="Pipe测试">

<h2 id="遇到的困难"><a href="#遇到的困难" class="headerlink" title="遇到的困难"></a>遇到的困难</h2><h3 id="困难1-测试文件系统出现Segment-Fault"><a href="#困难1-测试文件系统出现Segment-Fault" class="headerlink" title="困难1 测试文件系统出现Segment Fault"></a>困难1 测试文件系统出现Segment Fault</h3><p>尽管未对文件系统做任何修改，但是不论怎么执行都会得到<code>Segment Fault</code>的错误。使用命令<code>nachos -d</code>查看调试信息得知，程序执行到创建交换空间（或虚拟内存）文件时出现的错误，可以得知正是该文件的存在引发的错误。进一步调查发现，在<em>code&#x2F;userprog&#x2F;Makefile</em>中启用了<code>FILESYS_STUB</code>宏，该宏定义的作用是将Nachos的文件系统实现为本地Unix文件系统的封装，也就是说在实现用户线程的时候调用的文件系统是基于本地Unix的。然而在文件系统的<em>code&#x2F;filesys&#x2F;Makefile</em>文件中，并未启用<code>FILESYS_STUB</code>宏，这也就意味着此处使用的Nachos内部实现的文件系统，存在一个与Unix文件系统差异的点使得错误的发生。</p>
<p>最后调查发现了真正的问题所在。根据<em>code&#x2F;threads&#x2F;system.cc</em>中的<em>Initialize</em>函数得知，machine初始化，在“REAL”文件系统fileSystem之前。</p>
<img src="/2020/12/26/Nachos-Lab04-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20201231163600188.png" class="" title="初始化顺序">

<p>同时交换分区VirtualMemory是在Machine中初始化的，所以导致首次使用的时候，文件系统还是未格式化，却在Machine中尝试去创建文件了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * code/machine/machine.cc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Machine::<span class="built_in">Machine</span>(<span class="type">bool</span> debug)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SWAPING</span></span><br><span class="line">    swapBitMap = <span class="keyword">new</span> <span class="built_in">BitMap</span>(NumPhysPages * <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    fileSystem-&gt;<span class="built_in">Create</span>(<span class="string">&quot;VirtualMemory&quot;</span>, MemorySize * <span class="number">2</span>);</span><br><span class="line">    swapFile = fileSystem-&gt;<span class="built_in">Open</span>(<span class="string">&quot;VirtualMemory&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决办法</strong>：修改交换分区VirtualMemory的初始化位置，将其放在文件系统中初始化。</p>
<p>为了避免大量修改代码，交换分区仍放在Machine类中，但是将其初始化的部分取出封装成一个函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Machine::CreateSwap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    swapBitMap = <span class="keyword">new</span> <span class="built_in">BitMap</span>(NumPhysPages * <span class="number">2</span>);</span><br><span class="line">    fileSystem-&gt;<span class="built_in">Create</span>(<span class="string">&quot;VirtualMemory&quot;</span>, MemorySize * <span class="number">2</span>);</span><br><span class="line">    swapFile = fileSystem-&gt;<span class="built_in">Open</span>(<span class="string">&quot;VirtualMemory&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后将其放在文件系统之后被初始化。</p>
<img src="/2020/12/26/Nachos-Lab04-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20201231164825409.png" class="" title="交换分区初始化">

<h3 id="困难2-文件系统测试函数无法执行"><a href="#困难2-文件系统测试函数无法执行" class="headerlink" title="困难2 文件系统测试函数无法执行"></a>困难2 文件系统测试函数无法执行</h3><p>传入nachos中与文件系统相关的参数，不会执行。尽管使用了<code>-t</code>参数去调用<em>PerformanceTest</em>测试函数，但是真正执行的却是<em>ThreadTest</em>测试函数。</p>
<img src="/2020/12/26/Nachos-Lab04-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20201216162750699.png" class="" title="文件系统测试错误">

<p>经过阅读<em>code&#x2F;threads&#x2F;main.cc</em>可以发现如果定义了<em>THREADS</em>宏，则线程测试函数会先读走一个命令行参数，处理完线程测试函数之后，才会继续执行后续的用户线程、文件系统以及网络的测试。然后再进一步查看<em>code&#x2F;filesys&#x2F;Makefile</em>文件，可以发现文件系统启用了<code>THREADS</code>宏。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEFINES = -DTHREADS -DUSER_PROGRAM -DVM -DFILESYS_NEEDED -DFILESYS</span><br></pre></td></tr></table></figure>

<p>另外，经过对<code>THREADS</code>宏的作用进行调查，发现该宏定义与否不涉及线程功能的实现。大部分的宏的用于在Nachos中启用某个功能，如<em>USER_PROGRAM</em>、<em>USE_TLB</em>等；而<code>THREADS</code>则仅用于在main.cc文件中启用线程测试。</p>
<p><strong>解决办法</strong>：将<em>code&#x2F;filesys&#x2F;Makefile</em>中的<code>THREADS</code>宏删去。因为对Makefile文件进行了改动，因此需要先删除之前编译好的object文件（.o文件）然后重新编译。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] 百度文库. Nachos文件系统实习报告[EB&#x2F;OL]. <a target="_blank" rel="noopener" href="https://wenku.baidu.com/view/cb066179941ea76e59fa0485.html?re=view">https://wenku.baidu.com/view/cb066179941ea76e59fa0485.html?re=view</a></p>
<p>[2] 百度文库. nachos Lab5实习报告[EB&#x2F;OL]. <a target="_blank" rel="noopener" href="https://wenku.baidu.com/view/04382358f6ec4afe04a1b0717fd5360cbb1a8d40.html?re=view">https://wenku.baidu.com/view/04382358f6ec4afe04a1b0717fd5360cbb1a8d40.html?re=view</a></p>
</div><div class="article-licensing box"><div class="licensing-title"><p>Nachos Lab04 文件系统</p><p><a href="https://rlyown.github.io/2020/12/26/Nachos-Lab04-文件系统/">https://rlyown.github.io/2020/12/26/Nachos-Lab04-文件系统/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>Chaos Chen</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2020-12-26</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2023-06-30</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Nachos/">Nachos</a><a class="link-muted mr-2" rel="tag" href="/tags/FileSystem/">FileSystem</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/01/02/Nachos-Lab05-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Nachos Lab05 系统调用</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/11/25/%E5%9C%A8TPM2-0%E4%B8%8B%E4%BD%BF%E7%94%A8IMA-EVM/"><span class="level-item">在TPM2.0下使用IMA/EVM</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Commentaires</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "fe90ded45538f8468fac43e764833880",
            repo: "rlyown.github.io",
            owner: "Rlyown",
            clientID: "0dc9a246a80c473e7d31",
            clientSecret: "08612f9152910db6288e61191a4221bad6aea8e5",
            admin: ["Rlyown"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 20,
            pagerDirection: "last",
            
            
            enableHotKey: true,
            language: "zh-CN",
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#文件系统的基本操作"><span class="level-left"><span class="level-item">1</span><span class="level-item">文件系统的基本操作</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Exercise-1-源代码阅读"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">Exercise 1 源代码阅读</span></span></a></li><li><a class="level is-mobile" href="#Exercise-2-扩展文件属性"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">Exercise 2 扩展文件属性</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#思路"><span class="level-left"><span class="level-item">1.2.1</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#实现"><span class="level-left"><span class="level-item">1.2.2</span><span class="level-item">实现</span></span></a></li><li><a class="level is-mobile" href="#测试"><span class="level-left"><span class="level-item">1.2.3</span><span class="level-item">测试</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Exercise-3-扩展文件长度"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">Exercise 3 扩展文件长度</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#思路-1"><span class="level-left"><span class="level-item">1.3.1</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#实现-1"><span class="level-left"><span class="level-item">1.3.2</span><span class="level-item">实现</span></span></a></li><li><a class="level is-mobile" href="#测试-1"><span class="level-left"><span class="level-item">1.3.3</span><span class="level-item">测试</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Exercise-4-实现多级目录"><span class="level-left"><span class="level-item">1.4</span><span class="level-item">Exercise 4 实现多级目录</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#思路-2"><span class="level-left"><span class="level-item">1.4.1</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#实现-2"><span class="level-left"><span class="level-item">1.4.2</span><span class="level-item">实现</span></span></a></li><li><a class="level is-mobile" href="#测试-2"><span class="level-left"><span class="level-item">1.4.3</span><span class="level-item">测试</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Exercise-5-动态调整文件长度"><span class="level-left"><span class="level-item">1.5</span><span class="level-item">Exercise 5 动态调整文件长度</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#思路-3"><span class="level-left"><span class="level-item">1.5.1</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#实现-3"><span class="level-left"><span class="level-item">1.5.2</span><span class="level-item">实现</span></span></a></li><li><a class="level is-mobile" href="#测试-3"><span class="level-left"><span class="level-item">1.5.3</span><span class="level-item">测试</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#文件访问的同步与互斥"><span class="level-left"><span class="level-item">2</span><span class="level-item">文件访问的同步与互斥</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Exercise-6-源代码阅读"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">Exercise 6 源代码阅读</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#源码阅读"><span class="level-left"><span class="level-item">2.1.1</span><span class="level-item">源码阅读</span></span></a></li><li><a class="level is-mobile" href="#SynchConsole思路"><span class="level-left"><span class="level-item">2.1.2</span><span class="level-item">SynchConsole思路</span></span></a></li><li><a class="level is-mobile" href="#SynchConsole实现"><span class="level-left"><span class="level-item">2.1.3</span><span class="level-item">SynchConsole实现</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Exercise-7-实现文件系统的同步互斥访问机制，达到如下效果"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">Exercise 7 实现文件系统的同步互斥访问机制，达到如下效果</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#思路-4"><span class="level-left"><span class="level-item">2.2.1</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#实现-4"><span class="level-left"><span class="level-item">2.2.2</span><span class="level-item">实现</span></span></a></li><li><a class="level is-mobile" href="#测试-4"><span class="level-left"><span class="level-item">2.2.3</span><span class="level-item">测试</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#Challenges题目"><span class="level-left"><span class="level-item">3</span><span class="level-item">Challenges题目</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Challenge-1-性能优化"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">Challenge 1  性能优化</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#思路-5"><span class="level-left"><span class="level-item">3.1.1</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#实现-5"><span class="level-left"><span class="level-item">3.1.2</span><span class="level-item">实现</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Challenge-2-实现pipe机制"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">Challenge 2 实现pipe机制</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#实现-6"><span class="level-left"><span class="level-item">3.2.1</span><span class="level-item">实现</span></span></a></li><li><a class="level is-mobile" href="#测试-5"><span class="level-left"><span class="level-item">3.2.2</span><span class="level-item">测试</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#遇到的困难"><span class="level-left"><span class="level-item">4</span><span class="level-item">遇到的困难</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#困难1-测试文件系统出现Segment-Fault"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">困难1 测试文件系统出现Segment Fault</span></span></a></li><li><a class="level is-mobile" href="#困难2-文件系统测试函数无法执行"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">困难2 文件系统测试函数无法执行</span></span></a></li></ul></li><li><a class="level is-mobile" href="#参考文献"><span class="level-left"><span class="level-item">5</span><span class="level-item">参考文献</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/f7.png" alt="Real Own" height="28"></a><p class="is-size-7"><span>&copy; 2023 Chaos Chen</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visité par <span id="busuanzi_value_site_uv">0</span> utilisateurs</span></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-hans");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Retour au sommet" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "Ce site Web utilise des cookies pour améliorer votre expérience.",
          dismiss: "Je l'ai!",
          allow: "Autorise les cookies",
          deny: "Déclin",
          link: "Apprendre encore plus",
          policy: "Politique relative aux cookies",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Sans titre)","posts":"Articles","pages":"Pages","categories":"Catégories","tags":"Tags"});
        });</script></body></html>